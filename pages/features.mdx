# 功能介绍

&emsp;&emsp;在开始体验 swpp 前，我们先来了解一下 swpp 都有哪些功能。

## 本地缓存和增量更新

&emsp;&emsp;一般情况下，我们浏览网站需要从服务器拉取文件（包括但不限于：html、css、js），然后浏览器才能渲染出最终的结果。为了提高用户体验、降低服务器压力，诞生了 [HTTP 缓存](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching)，不过 HTTP 缓存仍有一定的局限性：体系较为复杂、需要服务器支持、通常难以及时更新等……

&emsp;&emsp;而通过 Service Worker 进行本地缓存就能解决上述的很多痛点：

1. sw 的缓存体系非常简单，就是拦截用户请求然后使用 [Cache API](https://developer.mozilla.org/zh-CN/docs/Web/API/Cache) 读写缓存。
2. sw 完全不依赖服务器实现，只要提供给用户 sw 的 js 文件，DOM 中添加相关支持，即可体验完整的功能。

&emsp;&emsp;但是 Service Worker 整体有一定的复杂度，且使用简单的实现仍然无法解决无法及时更新缓存的问题，此时 swpp 就派上了用场。

&emsp;&emsp;swpp 通过增量更新，在构建网站时扫描需要缓存的内容，确定本次更新需要更新哪些缓存，客户端就可以主动使这些缓存失效，从而解决缓存无法及时更新的问题。

&emsp;&emsp;swpp 同时支持按时间过期和永久缓存两种缓存方式，两种方式都可以使用增量更新。

## 缓存大小限制和预缓存

&emsp;&emsp;预缓存是指在网站加载时，预先缓存一些用户可能使用的资源。该功能妥善使用的话可以优化用户体验，但是为了避免用户滥用，swpp 没有内置该功能。

&emsp;&emsp;swpp 目前没有内置对缓存大小限制和预缓存的支持代码，但是用户可以通过自己配置，轻松实现这一功能。

## Request 篡改和 204 阻塞响应

&emsp;&emsp;启用 sw 后一个请求的流程为：DOM 端发送请求 \-> SW 端拦截并处理请求 \-> SW 端发送网络请求或直接返回。

&emsp;&emsp;swpp 允许用户在 SW 端修改请求的内容，相当于一个本地的加强版重定向，同时也可以选择直接在 SW 阻塞掉某个请求。

## URL 竞速和备用 URL

&emsp;&emsp;对于 `npm` `cdnjs` 或 `github` 之类平台上的资源，通常有多个 CDN 可用。

&emsp;&emsp;通过 URL 竞速，可以同时拉取这些 CDN 上的文件，然后取响应速度最快的一个作为最终结果。

&emsp;&emsp;而通过备用 URL，则可以优先访问原始的 URL，如果响应超时或失败，则同时拉取剩余 CDN 上的文件，然后取响应速度最快的一个作为最终结果。

## 逃生门

&emsp;&emsp;swpp 的缓存增量更新需要 DOM 端发送消息到 SW 端，如果 DOM 端实现错误导致无法发送消息且 DOM 端代码被永久缓存，那么靠普通手段是完全没有办法解决这个死循环的，逃生门的作用就是触发时强制更新缓存来解开这个死局。