{"/config/compilation_env":{"title":"构建期环境变量","data":{"":"构建期使用的环境变量。  该配置项用于放置仅需要在 NodeJs 环境中使用的环境变量。  对于每一项配置 <KEY>: <value | function(): value>：<KEY> 是属性名（推荐函数使用小写驼峰，常量使用大写下划线式命名），<value> 是环境变量的值。  该环境变量中的代码在 NodeJs 环境下执行，执行结果不会被放入 sw.js 中。","domain_host#DOMAIN_HOST":"类型\t说明\t默认值\tURL\t网站地址\tnew URL('https://www.example.com')\t\n  该项用于告知 swpp 您的网站所在的 URL 地址，swpp 通过该属性判断一个资源是否是外部资源、计算 swpp 文件在线上的地址。","service_worker#SERVICE_WORKER":"类型\t说明\t默认值\tstring\tsw 文件名\tsw\t\n  该项用于告知 swpp 您的 sw 生成的路径及名称，编写时不需要携带拓展名，默认生成到 /sw.js。","json_html_limit#JSON_HTML_LIMIT":"类型\t说明\t默认值\tnumber\tHTML 数量限制，设置为非正整数表示不限制\t0\t\n  该项用于控制单次刷新 HTML 的最大数量，当刷新的数量超过阈值后，swpp 将一次性清除所有的 HTML 缓存。  该项在您修改网站的所有或多数 HTML 时非常有用，可以避免在一个版本的更新内容中写入大量的字符串。","version_length_limit#VERSION_LENGTH_LIMIT":"类型\t说明\t默认值\tnumber\t版本信息长度限制\t1024\t\n  该项用于控制版本文件的最大长度，swpp 保证版本文件中的版本信息的长度之和不超过指定的值。设置为 0 可以禁用长度限制，但会导致版本文件无限制的增长，后面随时可能会禁止设置为 0。  swpp 限制长度的策略是不断移除最远的一个版本号，直到长度满足要求。","swpp_json_file#SWPP_JSON_FILE":"类型\t说明\t默认值\tobject\tJSON 文件的基本信息\t省略\t\n  该项用于配置与 swpp 与生成和获取数据文件相关的操作，具体的类型和解释如下：\n// noinspection TypeScriptUnresolvedReference\ninterface Type {\n    /** 生成的数据文件的目录，默认值：`swpp` */\n    swppPath: string\n    /** 后台 tracker 信息的文件名，默认值：`tracker.json` */\n    trackerPath: string\n    /** 版本文件的文件名，默认值：`update.json` */\n    versionPath: string\n    /**\n     * 拉取 tracker 文件，默认操作是从网络中拉取文件并解析。\n     *\n     * 拉取的地址为：`https://{DOMAIN_HOST}/{swppPath}/{trackerPath}`\n     */\n    fetchTrackerFile: (\n      compilation: CompilationData,\n    ) => Promise<FileUpdateTracker>\n    /**\n     * 拉取版本文件，默认操作是从网络中拉取文件并解析。\n     *\n     * 拉取的地址为：`https://{DOMAIN_HOST}/{swppPath}/{versionPath}`\n     */\n    fetchVersionFile: () => Promise<UpdateJson>\n}\n  修改该项配置时，可以仅修改部分字段，比如传入：{ swppPath: 'example/hello' } 可以仅修改 swppPath 的值，而其它的值保持默认。","network_file_fetcher#NETWORK_FILE_FETCHER":"类型\t说明\t默认值\tNetworkFileHandler\t拉取网络文件\tFiniteConcurrencyFetcher\t\n  该配置项用于修改 swpp 从网络中拉取文件的行为，其类型定义如下：\ninterface NetworkFileHandler {\n    /** 最大并发量，当并发量超过此限制时，后到达的请求应当等待队列中的请求完成。默认为：100 */\n    limit: number\n    /** 拉取文件时使用的 referer，默认为：https://swpp.example.com */\n    referer: string\n    /** 拉取文件时使用的 ua，默认为：swpp-backends */\n    userAgent: string\n    /** 需要额外写入的 header */\n    headers: { [name: string]: string }\n    /** 拉取文件 */\n    fetch(request: RequestInfo | URL): Promise<Response>\n    /** 获取指定文件的类型 */\n    getUrlContentType(url: string, response?: Response): string\n}\n  默认的实现已经可以满足绝大多数要求，大多数情况下不需要修改 fetch 和 getUrlContentType。  默认实现使用 NodeJS 内置的 fetch 函数拉取文件，对于使用低版本 NodeJS 的用户，则需要自行覆盖 fetch 的实现。","allow_not_found#ALLOW_NOT_FOUND":"类型\t说明\t默认值\tAllowNotFoundEnum\t404 等级\tALLOW_STATUS\t\n  该配置项用于设置拉取数据文件时能够接受的 404 级别。共分为三个级别：\nALLOW_ALL: 允许任何形式的 404（response 返回 404 状态码、DNS 解析错误等）\nALLOW_STATUS: 允许 response 返回 404 状态码\nREJECT_ALL: 不允许任何形式的 404 错误\n  当遇到不允许的 404 错误时 swpp 将直接结束构建，设置合理的报错等级可以防止网站被错误地部署到线上，从而导致历史版本丢失。","isstable#isStable":"类型\t说明\t默认值\t(url: URL) => boolean\t检查一个链接是否是稳定的\t() => false\t\n  该配置项用于检查一个链接是否是稳定的，也就是 URL 不变其返回的结果永远不变。  合理地设置该项可以加快 swpp 构建的速度，减少网络请求的数量。","readlocalfile#readLocalFile":"类型\t说明\t默认值\t(path: string) => Promise<crypto.BinaryLike>\t从本地读取一个文件\t省略\t\n  该配置项用于从本地读取一个文件，其接受一个参数 path，可能为绝对路径也可能为相对路径，默认实现使用 fs 以 UTF-8 编码读取文件。  对于 HTML、CSS、JS 类型的文件，必须返回 string，其它类型的文件只需要满足 crypto.BinaryLike 即可。","isnotfound#isNotFound":"类型\t说明\t默认值\tobject\t判断一个请求是否是 404 错误\t省略\t\n  该配置项用于判断一个请求的结果是否是 404 错误，默认实现如下：\nexport default {\n    /**\n     * 通过 response 判断是否是 404，在这里返回 true 均会被认定为状态码 404\n     *\n     * 注意不能直接读取传入的 response 的 body，如果需要修改先 clone 一下\n     *\n     * @return 返回 `true` 表示判定为 404\n     */\n    response: (response: Response) => response.status == 404,\n    /**\n     * 当拉取文件报错时通过该函数判断是否是 404\n     * @return 返回 `true` 表示判定为 404\n     */\n    error: (err: any) => err?.cause?.code === 'ENOTFOUND'\n};"}},"/config/modifier":{"title":"Modifier","data":{}},"/config/runtime_core":{"title":"Runtime Core","data":{}},"/config/runtime_dep":{"title":"Runtime Dep","data":{}},"/config/runtime_event":{"title":"Runtime Event","data":{}},"/":{"title":"Service Worker Plus Plus","data":{"什么是-swpp#什么是 swpp":"swpp 是一个用于为网站快速生成一个高度可用的 Service Worker 的工具，旨在提高网站的可靠性、优化二次访问性能、提供离线浏览功能……  常用 SW 构建工具的对比：\n\tswpp@3\tswpp@2\thexo-offline\t本地缓存\t✔️\t✔️\t✔️\t缓存增量更新\t✔️\t✔️\t❌\t缓存过期时间\t✔️\t❌\t✔️\t缓存大小限制\t❌\t❌\t✔️\t预缓存\t❌\t❌\t✔️\tRequest 篡改\t✔️\t✔️\t❌\tURL 竞速\t✔️\t✔️\t❌\t备用 URL\t✔️\t✔️\t❌\t204 阻塞响应\t✔️\t✔️\t❌\t逃生门\t✔️\t✔️\t❌\t请求合并\t❌\t✔️\t❌\t高度自由\t✔️\t✔️\t❌\t更新\t活跃\t停止维护\t超过两年没有更新","swpp-v2-与-v3-的区别#swpp v2 与 v3 的区别":"swpp v3 对 swpp 的所有代码进行了完全的重构，现在代码逻辑更加的清晰。除了后台代码的差异，v3 还有以下一系列的改进：\n完全定制化\n现在您对 swpp 生成的 sw 拥有完全的控制权。在 v2 中，如果需要修改插件生成的 sw 的逻辑，您需要自行编写整个 sw 文件。\nv3 中将 sw 文件的各个部分拆分到了环境变量中，这使得您可以通过配置文件覆盖 sw 文件中的任意一个部分，或者追加任意内容。\n现代化配置\n现在您可以使用 ts 语言编写配置文件，同时还可以选择使用 ESM。在 v2 中您必须使用 CommonJS。\n同时使用内置的一系列 define 函数可以让您对配置的颗粒度进行更加完美的掌控。\n完善的类型\n现在 swpp 提供了更加优雅的数据类型，以优化编写配置项、二次开发时的体验。","约定#约定":"在正式开始前您需要知道下面的事：\n本文档统一使用 npm 指令，您可根据喜好替换为自己使用的命令。\n在使用 swpp 之前您应当具备 ts/js 的部分知识，否则您可能会遇到一些麻烦。\nswpp 分为前后端实现，如不特别声明，均指后端实现。本文档是后端实现的文档。\n文档中的示例代码中出现的 // noinspection xxx 注释用于在编写文档时消除 IDE 警告，不需要 CV 走。","版本号#版本号":"目前 swpp v3 还在测试阶段，版本号全部采用 3.0.0-alpha.<a><b><c> 的格式：\n3.0.0 - 大版本号\nalpha - 测试版本\na - 一级子版本号，变动时表明 API 或配置文件等内容发生了不向前兼容的变动\nb - 二级子版本号，变动时表明添加了新的功能\nc - 三级子版本号，变动时表明进行了漏洞修复\n  当 a b c 的某一位达到两位数时，会在其中添加 x 表示分割。","历史文档#历史文档":"本文档不保存历史版本，因为本人永远推荐用户使用最新版的 swpp，旧版的 swpp 很可能是不安全的。"}},"/quickstart":{"title":"在您的项目中快速添加 swpp 支持","data":{"":"在本章之中，您将了解如何安装、使用 swpp。","结构介绍#结构介绍":"swpp 将实现分为了前端实现和后端实现，其中后端实现是唯一的，而前端实现在不同平台会有不同的实现。  swpp 对前端的具体实现没有太多限制，所以前端实现的安装、使用方法请阅读其提供的文档。下文中将为您介绍后端的安装、使用方法。  下面是已知的前端实现：\n平台\t插件名\t文档\t作者\thexo\thexo-swpp\tgithub\t空梦","安装#安装":"在项目中安装 swpp 后端非常简单，只需要运行下面的指令即可：\nnpm install swpp-backends@3","创建配置文件#创建配置文件":"swpp 支持以下类型的配置文件：ts js mts cts mjs cjs。  配置文件的文件名及所在路径请见您使用的前端实现的文档，此处我们假设配置文件名称为 swpp.config.ts。  接下来需要在其中填入下面的内容（注意将 DOMAIN_HOST 替换为您的 host）：\nimport { defineConfig } from 'swpp-backends';\nexport default defineConfig({\n    compilationEnv: {\n        // 此项是必须配置的项目，swpp 必须知道您的域名才能区分哪些资源是外部资源。\n        // 部分前端实现可能会帮您自动填写该项目，具体是否必须手动填写请见前端实现的文档。\n        DOMAIN_HOST: new URL('https://www.example.com')\n    }\n})\n  此时您就完成了配置 swpp 所必须的步骤。","生成-sw-与数据#生成 sw 与数据":"生成 sw 与数据文件的操作视前端的具体实现而定。"}},"/config":{"title":"配置文件的详细说明","data":{"":"本章将带您了解 swpp 的配置文件的组成，以及对 swpp 内置的所有配置项的解释说明。","环境#环境":"无论您是使用 js 还是 ts 编写配置文件，配置文件都将与主体程序共享同一个运行环境，也就是说配置文件中的代码可以访问到主体程序提供的 globalThis 等全局数据。  简单来说就是 swpp 会使用类似于 require('xxx/xxx/xxx') 的方式加载配置文件，所以相当于您在当前的项目中又编写了一个代码文件。  知道了这个，就可以在配置文件中进行一些“骚操作”，即可以动态地修改环境中的一些内容。但是 swpp 并不建议这么做，配置文件在设计上用于修改、调整 swpp 的一些行为，如果您确实需要运行一段有副作用的代码，建议优先通过其它更合理的办法进行。  swpp 会在加载配置时执行配置文件中的代码，如果您在配置文件顶层抛出了异常，那么将会导致配置加载失败，具体会产生什么后果视前端的具体实现而不同，可能会使整个程序直接结束，也可能只终止 swpp 的任务。  因为配置文件共享主程序的 package.json，所以配置文件中可以使用所有主程序中安装的依赖（包括 swpp 本身）。","导出配置的方法#导出配置的方法":"导出配置：指将您的配置暴露给调用程序（也就是 swpp），swpp 无法读取您未导出的内容。  swpp 支持两种导出配置的方法，一种是使用 export default，一种是使用 export const xxx，两种方式最终效果相同，可以根据个人喜好选择一种使用。  注意：swpp 内部通过判断配置文件是否导出了 default 来判断您使用的是哪一种导出方法，所以这两种方法并不能共存，如果您导出了 default，swpp 将忽略其它所有导出的内容。\n  当您使用 export default 导出配置时，您可以借助 SwppConfigTemplate 类型，这个类型可以帮助您进行配置设置，IDE\n支持的话还可以提供自动补全。下面是一段示例代码，其中列出了 swpp 内置的所有可调节配置分类：\nimport {defineConfig} from 'swpp-backends'\nexport default defineConfig({\n    compilationEnv: {},\n    crossEnv: {},\n    runtimeDep: {},\n    crossDep: {},\n    runtimeCore: {},\n    runtimeEvent: {},\n    domConfig: {},\n    compilationFileParser: {},\n    modifier: {}\n})\n  当您使用 export const 导出配置时，您需要使用具体的子类型来帮助您进行配置设置，IDE 支持的话还可以提供自动补全。下面是一段示例代码，其中列出了 swpp 内置的所有可调节配置分类：\nimport {\n    defineCompilationEnv, defineCompilationFP,\n    defineCrossDep, defineCrossEnv,\n    defineDomConfig, defineModifier,\n    defineRuntimeCore, defineRuntimeDep, defineRuntimeEvent\n} from 'swpp-backends'\nexport const compilationEnv = defineCompilationEnv({})\nexport const crossEnv = defineCrossEnv({})\nexport const runtimeDep = defineRuntimeDep({})\nexport const crossDep = defineCrossDep({})\nexport const runtimeCore = defineRuntimeCore({})\nexport const runtimeEvent = defineRuntimeEvent({})\nexport const domConfig = defineDomConfig({})\nexport const modifier = defineModifier({})\n  注意：上面的示例中一次性列出了所有的分类，实际使用时，建议只写出需要修改的配置，以保持配置文件的简洁性。","配置分类与命名规则#配置分类与命名规则":"从上面的示例代码中可以看到，swpp 将内置的配置项分为了八类，其命名规则如下：\ncompilation 开头表示该分类下的配置仅在构建时产生影响，不会被写入到 sw 文件中。\nruntime 开头表示该分类下的配置仅会被写入到 sw 文件中，不会在构建时被使用。\ncross 开头表示该分类下的配置在构建时有可能被使用，同时会被写入到 sw 文件中。\ndom 开头表示该分类下的配置会影响 DOM 端 js 的生成。\nmodifier 是一项非常特殊且功能强大的配置，后面将会专门进行讲解。"}},"/config/cross_dep":{"title":"双期函数依赖","data":{"":"运行时和编译期的函数依赖，其中的内容会被写入到 sw 中。  该配置项用于放置所有同时在浏览器和 NodeJs 环境下执行的工具函数。  对于每一项配置 <KEY>: { <runOnBrowser>, <runOnNode> }：<KEY> 是函数名，<runOnBrowser> 是在浏览器环境下执行的代码，<runOnNode> 是在 NodeJs 环境下执行的代码。  对于在浏览器环境下执行的代码，可以像 RuntimeDep 一样引用其它运行时的环境变量、依赖函数等内容。  对于在 NodeJs 环境下执行的代码，可以使用 this 调用 <runOnBrowser>（前提是 <runOnBrowser> 中没有依赖浏览器环境的代码）。  <runOnBrowser> 和 <runOnNode> 中的代码的行为应当完全一致。注意：此处说的行为一致是两者应当产生相同的副作用，内部具体实现可以不一样。  例：\n// noinspection TypeScriptUnresolvedReference\nexport const crossDep = defineCrossDep({\n    example: {  // 不推荐！双端的行为不完全一致！但如果是为了进行代码测试，可以临时这么干。\n        runOnBrowser: () => console.log('hello'),\n        runOnNode: () => console.log('world')\n    },\n    invokeExample: {\n        runOnBrowser: () => console.log('hello world'),\n        runOnNode() {\n            this.runOnBrowser()\n        }\n    }\n})","matchcacherule#matchCacheRule":"类型\t说明\t默认值\t(url: URL) => number | false | null | undefined\t判断一个资源是否需要缓存\t() => false\t\n  该项用于判断一个资源是否需要被前端缓存，其中各个返回值的含义如下：\nfalse null undefined 或 0：表示不需要缓存\n正数：表示需要缓存，缓存类型为定时缓存，单位为毫秒，超过指定时间后缓存自动失效\n负数：表示需要缓存，缓存类型为永久缓存，仅能通过增量更新失效","normalizeurl#normalizeUrl":"类型\t说明\t默认值\t(url: string) => string\t归一化 URL\t省略\t\n  该项用于将链接进行归一化，归一化的作用是防止目标相同但连接形式不同的资源被重复缓存。默认的实现会对 HTML 资源的 URL 进行处理：\n如果链接以 /index.html 结尾会被替换为 /\n如果链接以 /xxx.html 结尾会被替换为 /xxx\n否则保持原链接","matchupdaterule#matchUpdateRule":"类型\t说明\t默认值\t(exp: UpdateChangeExp) => ((url: string) => boolean | undefined | null)\t匹配缓存更新规则\t省略\t\n  该项用于判断一个 UpdateChangeExp 应当如何被程序理解，返回一个函数，该函数用于判断指定资源是否应该被刷新。  内置的规则已经可以满足大多数情况的要求，一般只有需要自定义新的规则时才需要修改该项，具体的实现可以参考 源代码。"}},"/config/cross_env":{"title":"双期环境变量","data":{"":"该配置项用于放置需要同时在浏览器环境和 NodeJs 环境中使用的环境变量，其中的内容会被写入到 sw 中。  对于每一项配置 <KEY>: <value | function(): value>：<KEY> 是函数名（推荐使用大写下划线式命名），value 是环境变量的值。  环境变量中应对仅包含非函数内容，当填写的配置项为函数时，swpp 会将函数返回的内容插入到环境变量中。  配置项填写的函数的执行环境为 NodeJs，所以不要编写依赖浏览器环境的代码。  例：\n// 该代码将在 sw.js 中插入一系列常量，同时在编译期也可以动态读取\n// const EXAMPLE = 'hello swpp'\n// const FUN_EXAMPLE = 'fun hello swpp'\n// noinspection TypeScriptUnresolvedReference\nexport const crossEnv = defineCrossEnv({\n    EXAMPLE: 'hello swpp',\n    FUN_EXAMPLE: function() {\n        return 'fun ' + this.crossEnv.read('EXAMPLE')\n    }\n})","cache_name#CACHE_NAME":"类型\t说明\t默认值\tstring\t缓存库名称\tkmarBlogCache\t\n  该配置项用于设置 swpp 存储缓存的缓存库的名称，可以更改为任意值，默认设置使用 kmarBlogCache 是历史遗留问题。  请注意：网站部署到线上之后请勿修改该值！除非您知道自己在做什么，否则修改该值可能会造成 swpp 工作异常。","version_path#VERSION_PATH":"类型\t说明\t默认值\tstring\t版本信息地址\thttps://id.v3/\t\n  该配置项用于设置版本信息存储的地址，因为 swpp 将版本信息封装为 Response 存储到 Cache 当中，所以需要一个模拟的链接来作为 key。此链接设置为一个网站不可能访问的地址即可，一定要以 / 结尾。  注意：网站部署到线上后请勿修改该值！除非您知道自己在做什么，否则修改该值可能会造成 swpp 工作异常。","escape#ESCAPE":"类型\t说明\t默认值\tnumber\t逃生门版本号\t0\t\n  该配置项用于设置逃生门的版本号，用户的逃生门信息会存储到版本信息当中，当用户本地的逃生门与设置的逃生门版本号不同时就会触发逃生门。  swpp 进行增量更新的原理是网站 DOM 端在启动时发送一个消息到 SW 端，SW 收到信息后开始进行更新操作。如果用户错误地修改了 DOM 端的代码，导致无法发送信息到 SW 端将导致 swpp 永远无法进行增量更新。此时如果对 DOM 的 JS 使用了无限期缓存，将会产生一个死循环：“修复 DOM JS 需要增量更新，但是增量更新又需要已有的 DOM JS 工作正常”。  逃生门的作用就是为了解决上述问题，当用户由于修改 DOM JS 或其它操作产生了无法修复的问题时，可以通过逃生门强制清除用户本地缓存的所有数据。  注意：只要用户的版本号和设置的版本号不相等就会触发逃生门。","invalid_key#INVALID_KEY":"类型\t说明\t默认值\tstring\t缓存失效标识的 key\tX-Swpp-Invalid\t\n  swpp 使缓存失效的原理是将失效的缓存打上一个失效标记，读取缓存时检查是否存在失效标记，如果存在则尝试通过网络拉取最新的内容然后替换缓存，拉取失败则继续使用缓存的内容。  该配置项用于修改 swpp 使用的 key，这个 key 是存储在响应头当中的，所以必须是一个合法的 HTTP 响应头名称。  注意：网站部署到线上后请勿修改该值！除非您知道自己在做什么，否则修改该值可能会造成 swpp 工作异常。","storage_timestamp#STORAGE_TIMESTAMP":"类型\t说明\t默认值\tstring\t缓存时间戳的 key\tX-Swpp-Time\t\n  swpp 实现定期缓存的原理是在响应头中存储一个时间戳，该配置项用于修改 swpp 使用的响应头的名称。  注意：网站部署到线上后请勿修改该值！除非您知道自己在做什么，否则修改该值可能会造成 swpp 工作异常。","update_cd#UPDATE_CD":"类型\t说明\t默认值\tnumber\t检查更新的最短时间间隔（毫秒）\t600000\t\n  该项用于设置检查更新的最短时间间隔，当第二次更新与第一次更新时间之差小于该值时，将会取消第二次更新，避免用户频繁刷新时不停的进行更新。","update_json_url#UPDATE_JSON_URL":"类型\t说明\t默认值\tstring\t版本文件所在 URL\t省略\t\n  该项自动生成，仅用于向 sw 中插入数据，不要手动填写。"}},"/config/dom_config":{"title":"DOM JS 相关配置","data":{"":"运行时使用的常量、函数。  该配置项用于放置需要生成到 dom. js 中的内容。  对于每一项配置 <KEY>: <value>：<KEY> 是常量名或函数名，常量推荐大写下划线命名，函数推荐小写驼峰命名，<value> 是值。  该配置项中的值只能使用本配置项中包含的内容，不能使用其它编译期、运行期的内容。  该配置项中所有以 _inline 开头的内容必须为 () => void 类型的函数，其将会以 (function content)() 的形式在插入的位置执行。","registry#registry":"类型\t说明\t默认值\t() => string\tSW 注册代码\t忽略\t\n  该项用于修改插入到 HTML 中的注册 SW 的代码。swpp 会在部分或所有（具体取决于前端的实现）HTML 的 <head> 中插入注册 SW 的代码。  默认的实现是：\nimport {defineDomConfig} from 'swpp-backends'\nexport const domConfig = defineDomConfig({\n    registry: () => {\n        const value = (() => {\n            const sw = navigator.serviceWorker\n            if (sw) {\n                sw.register('$$sw.js')\n                    .then(async registration => {\n                        console.log('SWPP 注册成功')\n                        try {\n                            // @ts-ignore\n                            await registration.periodicSync.register(\"update\", {\n                                minInterval: 24 * 60 * 60 * 1000\n                            })\n                        } catch (e) {\n                            console.warn('Periodic Sync 注册失败', e)\n                        }\n                    })\n                    .catch(err => console.error('SWPP 注册失败', err))\n            } else {\n                console.warn('当前浏览器不支持 SW')\n            }\n        }).toString()\n        // noinspection TypeScriptUnresolvedReference\n        const path = compilation.compilationEnv.read('SERVICE_WORKER')\n        return value.replace(`'$$sw.js'`, path + '.js')\n    }\n})\n  其最终会在 HTML 中插入如下代码（具体形式依赖前端实现，下面只是一个样例）：\n<script>\n    (() => {\n        const sw = navigator.serviceWorker\n        if (sw) {\n            sw.register('sw.js')\n                .then(async registration => {\n                    console.log('SWPP 注册成功')\n                    try {\n                        // @ts-ignore\n                        await registration.periodicSync.register(\"update\", {\n                            minInterval: 24 * 60 * 60 * 1000\n                        })\n                    } catch (e) {\n                        console.warn('Periodic Sync 注册失败', e)\n                    }\n                })\n                .catch(err => console.error('SWPP 注册失败', err))\n        } else {\n            console.warn('当前浏览器不支持 SW')\n        }\n    })()\n</script>\n  您可以参考这个提供自己的实现，以实现定制化的注册通知、失败通知等。示例代码中使用的 periodicSync 用于实现后台自动更新，浏览器对该事件的注册有限制，必须客户端通过 PWA 安装网站应用后才能生效，如果注册报错了也是正常现象，无需担心影响其它功能。  参考文档：\nregister | MDN\nPeriodic Sync | MDN","postmessage2sw#postMessage2Sw":"类型\t说明\t默认值\t(type: string) => void\t向 SW 发送信息\t忽略\t\n  该函数用于从 DOM 端向 SW 端发送消息，默认实现如下：\n// noinspection JSUnusedLocalSymbols\nconst postMessage2Sw = (type) => navigator.serviceWorker.controller.postMessage(type)\n  该实现通常不需要修改，如果您希望实现更多的功能，可以修改函数的参数类型，只需要保证传入一个字符串时能够正常运行即可。（当然如果把调用这个函数的地方都改了那么就什么限制都没有了。）","pjaxupdate#pjaxUpdate":"类型\t说明\t默认值\t(url: string) => void\t更新 pjax\t忽略\t\n  对于安装了 pjax 的用户来说，如果刷新缓存后直接使用代码刷新页面，那么 js 和 css 的更新将无法应用，所以对于启用 pjax 的用户需要使用该函数将页面中的 js 和 css 进行更新。  默认实现更新的原理是将需要更新的资源文件对应的引入标签从 DOM 中移除并重新放入；函数传入的 url 参数是本次更新的资源的 URL。","session_key#SESSION_KEY":"类型\t说明\t默认值\tstring\t存储 session 的 key\t'updated'\t\n  swpp 通过向 session 中存储一个临时数据来判断刚刚是否更新过缓存，此处用于修改这个 key。","onsuccess#onSuccess":"类型\t说明\t默认值\t() => void\t缓存更新成功时触发的操作\t控制台打印提示信息\t\n  该配置项传入的函数将会在缓存更新成功后触发。","_inlinea#_inlineA":"类型\t说明\t默认值\t() => void\t触发更新和 onSuccess\t省略\t\n  该配置项传入的代码块用于触发缓存的更新和 onSuccess。","messageevent#messageEvent":"类型\t说明\t默认值\t(event: MessageEvent) => void\t接受 SW 发送过来的消息\t省略\t\n  当 SW 发送消息到 DOM 端时会触发该事件，具体参考：MessageEvent | MDN。"}}}