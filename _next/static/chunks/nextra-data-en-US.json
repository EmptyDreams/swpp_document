{"/config/compilation_env":{"title":"构建期环境变量","data":{"":"构建期使用的环境变量。  该配置项用于放置仅需要在 NodeJs 环境中使用的环境变量。  对于每一项配置 <KEY>: <value | function(): value>：<KEY> 是属性名（推荐函数使用小写驼峰，常量使用大写下划线式命名），<value> 是环境变量的值。  该环境变量中的代码在 NodeJs 环境下执行，执行结果不会被放入 sw.js 中。","domain_host#DOMAIN_HOST":"类型\t说明\t默认值\tURL\t网站地址\tnew URL('https://www.example.com')\t\n  该项用于告知 swpp 您的网站所在的 URL 地址，swpp 通过该属性判断一个资源是否是外部资源、计算 swpp 文件在线上的地址。","service_worker#SERVICE_WORKER":"类型\t说明\t默认值\tstring\tsw 文件名\tsw\t\n  该项用于告知 swpp 您的 sw 生成的路径及名称，编写时不需要携带拓展名，默认生成到 /sw.js。","json_html_limit#JSON_HTML_LIMIT":"类型\t说明\t默认值\tnumber\tHTML 数量限制，设置为非正整数表示不限制\t0\t\n  该项用于控制单次刷新 HTML 的最大数量，当刷新的数量超过阈值后，swpp 将一次性清除所有的 HTML 缓存。  该项在您修改网站的所有或多数 HTML 时非常有用，可以避免在一个版本的更新内容中写入大量的字符串。","version_length_limit#VERSION_LENGTH_LIMIT":"类型\t说明\t默认值\tnumber\t版本信息长度限制\t1024\t\n  该项用于控制版本文件的最大长度，swpp 保证版本文件中的版本信息的长度之和不超过指定的值。设置为 0 可以禁用长度限制，但会导致版本文件无限制的增长，后面随时可能会禁止设置为 0。  swpp 限制长度的策略是不断移除最远的一个版本号，直到长度满足要求。","swpp_json_file#SWPP_JSON_FILE":"类型\t说明\t默认值\tobject\tJSON 文件的基本信息\t省略\t\n  该项用于配置与 swpp 与生成和获取数据文件相关的操作，具体的类型和解释如下：\n// noinspection TypeScriptUnresolvedReference,JSUnusedLocalSymbols\ninterface Type {\n    /** 生成的数据文件的目录，默认值：`swpp` */\n    swppPath: string\n    /** 后台 tracker 信息的文件名，默认值：`tracker.json` */\n    trackerPath: string\n    /** 版本文件的文件名，默认值：`update.json` */\n    versionPath: string\n    /**\n     * 拉取 tracker 文件，默认操作是从网络中拉取文件并解析。\n     *\n     * 拉取的地址为：`https://{DOMAIN_HOST}/{swppPath}/{trackerPath}`\n     */\n    fetchTrackerFile: (\n      compilation: CompilationData,\n    ) => Promise<FileUpdateTracker>\n    /**\n     * 拉取版本文件，默认操作是从网络中拉取文件并解析。\n     *\n     * 拉取的地址为：`https://{DOMAIN_HOST}/{swppPath}/{versionPath}`\n     */\n    fetchVersionFile: () => Promise<UpdateJson>\n}\n  修改该项配置时，可以仅修改部分字段，比如传入：{ swppPath: 'example/hello' } 可以仅修改 swppPath 的值，而其它的值保持默认。","network_file_fetcher#NETWORK_FILE_FETCHER":"类型\t说明\t默认值\tNetworkFileHandler\t拉取网络文件\tFiniteConcurrencyFetcher\t\n  该配置项用于修改 swpp 从网络中拉取文件的行为，其类型定义如下：\nimport * as http from 'node:http'\n// noinspection JSUnusedLocalSymbols\ninterface NetworkFileHandler {\n    /** 最大并发量，当并发量超过此限制时，后到达的请求应当等待队列中的请求完成。默认为：100 */\n    limit: number\n    /** 单个连接的超时时间（毫秒），默认为：5000 */\n    timeout: number\n    /** 拉取文件时使用的 referer，默认为：https://swpp.example.com */\n    referer: string\n    /** 拉取文件时使用的 ua，默认为：swpp-backends */\n    userAgent: string\n    /** HTTP 代理 */\n    proxy: http.Agent\n    /** 需要额外写入的 header */\n    headers: { [name: string]: string }\n    /** 拉取文件 */\n    fetch(request: RequestInfo | URL): Promise<Response>\n    /** 获取指定文件的类型 */\n    getUrlContentType(url: string, response?: Response): string\n    /**\n     * 判断请求失败后是否重试\n     * @param request 请求内容\n     * @param count 已重试次数（不包括本次）\n     * @param err 失败的原因\n     */\n    isRetry(request: RequestInfo | URL, count: number, err: any): boolean\n    /**\n     * 获取备用 URL 列表\n     * @param url\n     * @return 返回的数组中的第一个元素将用于替换原有的 URL\n     */\n    getStandbyList(url: string | URL): (string | URL)[]\n}\n  默认的实现已经可以满足绝大多数要求，大多数情况下不需要修改 fetch 和 getUrlContentType。对于内置的 FiniteConcurrencyFetcher 实现，还在 NetworkFileHandler 基础上额外添加了 retryLimit: number 字段，默认为 3，用于控制请求超时后的最大重试次数。  如果需要使用本地代理，可以提供 proxy 字段，下面以 https-proxy-agent 为例：\nimport { defineCompilationEnv } from 'swpp-backends'\nimport { HttpsProxyAgent } from 'https-proxy-agent'\ndefineCompilationEnv({\n    NETWORK_FILE_FETCHER: {\n        proxy: new HttpsProxyAgent('http://127.0.0.1:10809')\n    }\n})","allow_not_found#ALLOW_NOT_FOUND":"类型\t说明\t默认值\tAllowNotFoundEnum\t404 等级\tALLOW_STATUS\t\n  该配置项用于设置拉取数据文件时能够接受的 404 级别。共分为三个级别：\nALLOW_ALL: 允许任何形式的 404（response 返回 404 状态码、DNS 解析错误等）\nALLOW_STATUS: 允许 response 返回 404 状态码\nREJECT_ALL: 不允许任何形式的 404 错误\n  当遇到不允许的 404 错误时 swpp 将直接结束构建，设置合理的报错等级可以防止网站被错误地部署到线上，从而导致历史版本丢失。","isstable#isStable":"类型\t说明\t默认值\t(url: URL) => boolean\t检查一个链接是否是稳定的\t() => false\t\n  该配置项用于检查一个链接是否是稳定的，也就是 URL 不变时，使用这个 URL 拉取到的结果永远不变。  合理地设置该项可以加快 swpp 构建的速度，减少网络请求的数量。","readlocalfile#readLocalFile":"类型\t说明\t默认值\t(path: string) => Promise<crypto.BinaryLike>\t从本地读取一个文件\t省略\t\n  该配置项用于从本地读取一个文件，其接受一个参数 path，可能为绝对路径也可能为相对路径，默认实现使用 fs 以 UTF-8 编码读取文件。  对于 HTML、CSS、JS 类型的文件，必须返回 string，其它类型的文件只需要满足 crypto.BinaryLike 即可。","isnotfound#isNotFound":"类型\t说明\t默认值\tobject\t判断一个请求是否是 404 错误\t省略\t\n  该配置项用于判断一个请求的结果是否是 404 错误（该配置项仅影响 swpp 生成的数据文件的拉取任务），默认实现如下：\nexport default {\n    /**\n     * 通过 response 判断是否是 404，在这里返回 true 均会被认定为状态码 404\n     *\n     * 注意不能直接读取传入的 response 的 body，如果需要修改先 clone 一下\n     *\n     * @return 返回 `true` 表示判定为 404\n     */\n    response: (response: Response) => response.status == 404,\n    /**\n     * 当拉取文件报错时通过该函数判断是否是 404\n     * @return 返回 `true` 表示判定为 404\n     */\n    error: (err: any) => err?.cause?.code === 'ENOTFOUND'\n};"}},"/config/compilation_file_parser":{"title":"编译时文件解析器","data":{"":"构建期使用的文件处理器。  该配置项用于放置需要在 NodeJs 环境中使用的文件处理器。  对于每一项配置 <KEY>: <FileParser>: <KEY> 是文件拓展名（不包括 .），<FileParser> 是处理机。  解析器的作用是从文件中提取外部资源的 URL，以辅助 swpp 追踪资源链。  默认实现请参考 CompilationFileParser.ts 源码。","html#html":"swpp 使用第三方库解析 HTML 文件，并从中记录 script link 标签引入的资源的 URL，遇到 style 标签时还会调用 css 处理机处理 CSS 内容，同理遇到内嵌的 JS 代码时也会尝试使用 js 处理机处理 JS 内容。","css#css":"swpp 使用内置的文本处理器解析 CSS 文件中以 url(xxx) 格式引入的资源的 URL，解析时忽略注释中的内容。"}},"/config/cross_dep":{"title":"双期函数依赖","data":{"":"运行时和编译期的函数依赖，其中的内容会被写入到 sw 中。  该配置项用于放置所有同时在浏览器和 NodeJs 环境下执行的工具函数。  对于每一项配置 <KEY>: { <runOnBrowser>, <runOnNode> }：<KEY> 是函数名，<runOnBrowser> 是在浏览器环境下执行的代码，<runOnNode> 是在 NodeJs 环境下执行的代码。  对于在浏览器环境下执行的代码，可以像 RuntimeDep 一样引用其它运行时的环境变量、依赖函数等内容。  对于在 NodeJs 环境下执行的代码，可以使用 this 调用 <runOnBrowser>（前提是 <runOnBrowser> 中没有依赖浏览器环境的代码）。  <runOnBrowser> 和 <runOnNode> 中的代码的行为应当完全一致。注意：此处说的行为一致是两者应当产生相同的副作用，内部具体实现可以不一样。  例：\nimport {defineCrossDep} from 'swpp-backends'\ndefineCrossDep({\n    example: {  // 不推荐！双端的行为不完全一致！但如果是为了进行代码测试，可以临时这么干。\n        runOnBrowser: () => console.log('hello'),\n        runOnNode: () => console.log('world')\n    },\n    invokeExample: {\n        runOnBrowser: () => console.log('hello world'),\n        runOnNode() {\n            this.runOnBrowser()\n        }\n    }\n})","matchcacherule#matchCacheRule":"类型\t说明\t默认值\t(url: URL) => number | false | null | undefined\t判断一个资源是否需要缓存\t() => false\t\n  该项用于判断一个资源是否需要被前端缓存，其中各个返回值的含义如下：\nfalse null undefined 或 0：表示不需要缓存\n正数：表示需要缓存，缓存类型为定时缓存，单位为毫秒，超过指定时间后缓存自动失效\n负数：表示需要缓存，缓存类型为永久缓存，仅能通过增量更新失效","normalizeurl#normalizeUrl":"类型\t说明\t默认值\t(url: string) => string\t归一化 URL\t省略\t\n  该项用于将链接进行归一化，归一化的作用是防止目标相同但连接形式不同的资源被重复缓存。默认的实现会对 HTML 资源的 URL 进行处理：\n如果链接以 /index.html 结尾会被替换为 /\n如果链接以 /xxx.html 结尾会被替换为 /xxx\n否则保持原链接","matchupdaterule#matchUpdateRule":"类型\t说明\t默认值\t(exp: UpdateChangeExp) => ((url: string) => boolean | undefined | null)\t匹配缓存更新规则\t省略\t\n  该项用于判断一个 UpdateChangeExp 应当如何被程序理解，返回一个函数，该函数用于判断指定资源是否应该被刷新。  内置的规则已经可以满足大多数情况的要求，一般只有需要自定义新的规则时才需要修改该项，具体的实现可以参考 源代码。"}},"/config/cross_env":{"title":"双期环境变量","data":{"":"该配置项用于放置需要同时在浏览器环境和 NodeJs 环境中使用的环境变量，其中的内容会被写入到 sw 中。  对于每一项配置 <KEY>: <value | function(): value>：<KEY> 是函数名（推荐使用大写下划线式命名），value 是环境变量的值。  环境变量中应对仅包含非函数内容，当填写的配置项为函数时，swpp 会将函数返回的内容插入到环境变量中。  配置项填写的函数的执行环境为 NodeJs，所以不要编写依赖浏览器环境的代码。  例：\nimport {defineCrossEnv} from 'swpp-backends'\n// 该代码将在 sw.js 中插入一系列常量，同时在编译期也可以动态读取\n// const EXAMPLE = 'hello swpp'\n// const FUN_EXAMPLE = 'fun hello swpp'\ndefineCrossEnv({\n    EXAMPLE: 'hello swpp',\n    FUN_EXAMPLE: function() {\n        return 'fun ' + this.crossEnv.read('EXAMPLE')\n    }\n})","cache_name#CACHE_NAME":"类型\t说明\t默认值\tstring\t缓存库名称\tkmarBlogCache\t\n  该配置项用于设置 swpp 存储缓存的缓存库的名称，可以更改为任意值，默认设置使用 kmarBlogCache 是历史遗留问题。  请注意：网站部署到线上之后请勿修改该值！除非您知道自己在做什么，否则修改该值可能会造成 swpp 工作异常。","version_path#VERSION_PATH":"类型\t说明\t默认值\tstring\t版本信息地址\thttps://id.v3/\t\n  该配置项用于设置版本信息存储的地址，因为 swpp 将版本信息封装为 Response 存储到 Cache 当中，所以需要一个模拟的链接来作为 key。此链接设置为一个网站不可能访问的地址即可，一定要以 / 结尾。  注意：网站部署到线上后请勿修改该值！除非您知道自己在做什么，否则修改该值可能会造成 swpp 工作异常。","escape#ESCAPE":"类型\t说明\t默认值\tnumber\t逃生门版本号\t0\t\n  该配置项用于设置逃生门的版本号，用户的逃生门信息会存储到版本信息当中，当用户本地的逃生门与设置的逃生门版本号不同时就会触发逃生门。  swpp 进行增量更新的原理是网站 DOM 端在启动时发送一个消息到 SW 端，SW 收到信息后开始进行更新操作。如果用户错误地修改了 DOM 端的代码，导致无法发送信息到 SW 端将导致 swpp 永远无法进行增量更新。此时如果对 DOM 的 JS 使用了无限期缓存，将会产生一个死循环：“修复 DOM JS 需要增量更新，但是增量更新又需要已有的 DOM JS 工作正常”。  逃生门的作用就是为了解决上述问题，当用户由于修改 DOM JS 或其它操作产生了无法修复的问题时，可以通过逃生门强制清除用户本地缓存的所有数据。  注意：只要用户的版本号和设置的版本号不相等就会触发逃生门。","invalid_key#INVALID_KEY":"类型\t说明\t默认值\tstring\t缓存失效标识的 key\tX-Swpp-Invalid\t\n  swpp 使缓存失效的原理是将失效的缓存打上一个失效标记，读取缓存时检查是否存在失效标记，如果存在则尝试通过网络拉取最新的内容然后替换缓存，拉取失败则继续使用缓存的内容。  该配置项用于修改 swpp 使用的 key，这个 key 是存储在响应头当中的，所以必须是一个合法的 HTTP 响应头名称。  注意：网站部署到线上后请勿修改该值！除非您知道自己在做什么，否则修改该值可能会造成 swpp 工作异常。","storage_timestamp#STORAGE_TIMESTAMP":"类型\t说明\t默认值\tstring\t缓存时间戳的 key\tX-Swpp-Time\t\n  swpp 实现定期缓存的原理是在响应头中存储一个时间戳，该配置项用于修改 swpp 使用的响应头的名称。  注意：网站部署到线上后请勿修改该值！除非您知道自己在做什么，否则修改该值可能会造成 swpp 工作异常。","update_cd#UPDATE_CD":"类型\t说明\t默认值\tnumber\t检查更新的最短时间间隔（毫秒）\t600000\t\n  该项用于设置检查更新的最短时间间隔，当第二次更新与第一次更新时间之差小于该值时，将会取消第二次更新，避免用户频繁刷新时不停的进行更新。","update_json_url#UPDATE_JSON_URL":"类型\t说明\t默认值\tstring\t版本文件所在 URL\t省略\t\n  该项自动生成，仅用于向 sw 中插入数据，不要手动填写。"}},"/config/dom_config":{"title":"DOM JS 相关配置","data":{"":"运行时使用的常量、函数。  该配置项用于放置需要生成到 dom. js 中的内容。  对于每一项配置 <KEY>: <value>：<KEY> 是常量名或函数名，常量推荐大写下划线命名，函数推荐小写驼峰命名，<value> 是值。  该配置项中的值只能使用本配置项中包含的内容，不能使用其它编译期、运行期的内容。  该配置项中所有以 _inline 开头的内容必须为 () => void 类型的函数，其将会以 (function content)() 的形式在插入的位置执行。","registry#registry":"类型\t说明\t默认值\t() => string\tSW 注册代码\t忽略\t\n  该项用于修改插入到 HTML 中的注册 SW 的代码。swpp 会在部分或所有（具体取决于前端的实现）HTML 的 <head> 中插入注册 SW 的代码。  默认的实现是：\nimport {defineDomConfig} from 'swpp-backends'\ndefineDomConfig({\n    registry: () => {\n        const value = (() => {\n            const sw = navigator.serviceWorker\n            if (sw) {\n                sw.register('$$sw.js')\n                    .then(async registration => {\n                        console.log('SWPP 注册成功')\n                        try {\n                            // @ts-ignore\n                            await registration.periodicSync.register(\"update\", {\n                                minInterval: 24 * 60 * 60 * 1000\n                            })\n                        } catch (e) {\n                            console.warn('Periodic Sync 注册失败', e)\n                        }\n                    })\n                    .catch(err => console.error('SWPP 注册失败', err))\n            } else {\n                console.warn('当前浏览器不支持 SW')\n            }\n        }).toString()\n        // noinspection TypeScriptUnresolvedReference\n        const path = compilation.compilationEnv.read('SERVICE_WORKER')\n        return value.replace(`'$$sw.js'`, path + '.js')\n    }\n})\n  其最终会在 HTML 中插入如下代码（具体形式依赖前端实现，下面只是一个样例）：\n<script>\n    (() => {\n        const sw = navigator.serviceWorker\n        if (sw) {\n            sw.register('sw.js')\n                .then(async registration => {\n                    console.log('SWPP 注册成功')\n                    try {\n                        // @ts-ignore\n                        await registration.periodicSync.register(\"update\", {\n                            minInterval: 24 * 60 * 60 * 1000\n                        })\n                    } catch (e) {\n                        console.warn('Periodic Sync 注册失败', e)\n                    }\n                })\n                .catch(err => console.error('SWPP 注册失败', err))\n        } else {\n            console.warn('当前浏览器不支持 SW')\n        }\n    })()\n</script>\n  您可以参考这个提供自己的实现，以实现定制化的注册通知、失败通知等。示例代码中使用的 periodicSync 用于实现后台自动更新，浏览器对该事件的注册有限制，必须客户端通过 PWA 安装网站应用后才能生效，如果注册报错了也是正常现象，无需担心影响其它功能。  参考文档：\nregister | MDN\nPeriodic Sync | MDN","postmessage2sw#postMessage2Sw":"类型\t说明\t默认值\t(type: string) => void\t向 SW 发送信息\t忽略\t\n  该函数用于从 DOM 端向 SW 端发送消息，默认实现如下：\n// noinspection JSUnusedLocalSymbols\nconst postMessage2Sw = (type) => navigator.serviceWorker.controller.postMessage(type)\n  该实现通常不需要修改，如果您希望实现更多的功能，可以修改函数的参数类型，只需要保证传入一个字符串时能够正常运行即可。（当然如果把调用这个函数的地方都改了那么就什么限制都没有了。）","pjaxupdate#pjaxUpdate":"类型\t说明\t默认值\t(url: string) => void\t更新 pjax\t忽略\t\n  对于安装了 pjax 的用户来说，如果刷新缓存后直接使用代码刷新页面，那么 js 和 css 的更新将无法应用，所以对于启用 pjax 的用户需要使用该函数将页面中的 js 和 css 进行更新。  默认实现更新的原理是将需要更新的资源文件对应的引入标签从 DOM 中移除并重新放入；函数传入的 url 参数是本次更新的资源的 URL。","session_key#SESSION_KEY":"类型\t说明\t默认值\tstring\t存储 session 的 key\t'updated'\t\n  swpp 通过向 session 中存储一个临时数据来判断刚刚是否更新过缓存，此处用于修改这个 key。","onsuccess#onSuccess":"类型\t说明\t默认值\t() => void\t缓存更新成功时触发的操作\t控制台打印提示信息\t\n  该配置项传入的函数将会在缓存更新成功后触发。","_inlinea#_inlineA":"类型\t说明\t默认值\t() => void\t触发更新和 onSuccess\t省略\t\n  该配置项传入的代码块用于触发缓存的更新和 onSuccess。","messageevent#messageEvent":"类型\t说明\t默认值\t(event: MessageEvent) => void\t接受 SW 发送过来的消息\t省略\t\n  当 SW 发送消息到 DOM 端时会触发该事件，具体参考：MessageEvent | MDN。"}},"/config/runtime_event":{"title":"运行时事件","data":{"":"该配置项用于在 sw 中注册指定的事件，可以和 SwppConfigRuntimeDep 一样引用运行时的内容。  对于每一项配置 <KEY>: <function>：<KEY> 是事件名，<function> 是事件执行体。  请注意：除非您知道您在做什么，否则不要修改该分类下的内容！！！例：\n// noinspection TypeScriptUnresolvedReference\nimport {defineRuntimeEvent} from 'swpp-backends'\n// 该代码将在 sw. js 中插入事件注册代码\n// self.addEventListener('fetch', event => {\n//     // do something\n// })\n// 注意：编写 TS 时可能会遇到 FetchEvent 类型找不到的问题，\n// 这个问题暂时没有特别好的解决方案，把类型改成 any 或者 Event 然后用 @ts-ignore 忽略错误即可。\n// noinspection JSUnusedLocalSymbols\ndefineRuntimeEvent({\n    fetch: (event: FetchEvent) => {\n        // do something\n    }\n})","install#install":"类型\t说明\t(event: InstallEvent) => void\t安装事件\t\n  事件的解释见：install event | MDN。  默认实现如下：\n// noinspection TypeScriptUnresolvedReference\n(_event: InstallEvent) => {\n    skipWaiting()\n}","activate#activate":"类型\t说明\t(event: ExtendableEvent) => void\t激活事件\t\n  事件的解释参见：activate event | MDN。  默认实现如下：\n// noinspection TypeScriptUnresolvedReference,JSUnusedLocalSymbols,JSDeprecatedSymbols\n(event: ExtendableEvent) => event.waitUntil(clients.claim())","fetch#fetch":"类型\t说明\t(event: FetchEvent) => void\t网络请求事件\t\n  事件的解释见：fetch event | MDN。  默认实现如下：\n// noinspection TypeScriptUnresolvedReference,JSDeprecatedSymbols,JSUnusedLocalSymbols\n(event: FetchEvent) => handleFetchEvent(event)","periodicsync#periodicSync":"类型\t说明\t(event: PeriodicSyncEvent) => void\t同步事件\t\n  事件的解释见：periodicSync event | MDN。  默认实现如下：\n// noinspection TypeScriptUnresolvedReference,JSDeprecatedSymbols,JSUnusedLocalSymbols\n(event: PeriodicSyncEvent) => {\n    if (event.tag === 'update') {\n        event.waitUntil(handleUpdate(true))\n    }\n}","message#message":"类型\t说明\t(event: ExtendableMessageEvent) => void\t消息事件\t\n  事件的解释见：message event | MDN。  默认实现如下：\n// noinspection TypeScriptUnresolvedReference,JSDeprecatedSymbols,JSUnusedLocalSymbols\nasync (event: ExtendableMessageEvent) => {\n    const data = event.data\n    switch (data.type) {\n        case 'update':\n            const oldVersion = await readVersion()\n            const updateResult = await handleUpdate(oldVersion)\n            if (!updateResult) return\n            switch (updateResult) {\n                case -1:\n                    return postMessage('new', null)\n                case 1:\n                    return postMessage('revise', null)\n                case 2:\n                    return postMessage('update', null)\n                default:\n                    if (Array.isArray(updateResult)) {\n                        return postMessage('update', updateResult)\n                    }\n            }\n    }\n}"}},"/debug":{"title":"本地及线上调试方法","data":{"":"本篇将介绍如何在浏览器中观察和调试 SW 的功能。","开发者工具#开发者工具":"在大部分浏览器中，均可使用 F12 打开开发者工具（edge 可使用 ctrl + shift + I），我们在浏览器中的调试也全部在这个开发者工具中进行。","网络观察#网络观察":"在 网络 一栏中，我们可以监视当前网页的所有网络活动，也可以限制当前页的网络速度，具体的功能您可以自行探索。  如果您启用了 swpp 中与网络请求相关的功能（如本地缓存、备用 URL等），那么在网络信息中，就能发现部分请求出现了两次：  仔细观察就会发现这两个请求并不完全相同，主要区别在于一个是 kms.js 发起的，另一个是 sw.js 发起的，同时可以发现其中一个请求的“履行者”一栏写的是“ServiceWorker”。  当“履行者”一栏值为“ServiceWorker”时，表明该请求被 SW 拦截并代理，具体的操作由 SW 完成；当文件名左侧出现一个齿轮图标（或“发起者”是 SW 的 js 文件）时，表明该请求由 SW 发起。  如果一个请求被 SW 代理，但在网络请求中却找不到 SW 发起的请求，那么表明该请求走了本地缓存，直接从本地中读取了值。","观察-sw#观察 SW":"在 应用程序 > Service workers 一栏中，就可以观察到 SW 的注册情况：  这里主要列出了 SW 当前的状态，“来源”后如果出现红色叉号，表明 SW 文件当前或历史运行过程中出现过报错（网络报错也会计算在内）。  同时顶部还有三个选项可以使用，这三个选项的功能如下（这三个功能仅调试时使用）：\n脱机：禁止当前网页使用互联网（相当于把这个网页的网断了）\n重新加载时更新：刷新网页时更新 SW（不勾选的时候 SW 的更新可能会有延迟）\n网络旁路：禁止 SW 代理网络请求（打开后所有请求都会绕过 SW）\n  该页面中更具体的介绍可以参考：Chrome 文档。","观察缓存#观察缓存":"在 应用程序 > 缓存存储 > 您设置的缓存名称 一栏中，您可以查看 SW 创建的所有缓存信息：  在这个页面，您还可以手动删除某一个或全部缓存。","调试代码#调试代码":"在 源代码 > sw.js > 您的域名 > 您设置的 sw 名称 一栏中，您可以查看当前 sw 的代码，并可以进行断点调试。  具体使用方法参考：Chrome 文档，这里不再赘述。"}},"/features":{"title":"功能介绍","data":{"":"在开始体验 swpp 前，我们先来了解一下 swpp 都有哪些功能。章节下的子目录是对各个功能的具体说明，可以先跳过回过头再看，但是一定要记得回来看！！！里面会说明功能使用时的注意事项。","本地缓存和增量更新#本地缓存和增量更新":"一般情况下，我们浏览网站需要从服务器拉取文件（包括但不限于：html、css、js），然后浏览器才能渲染出最终的结果。为了提高用户体验、降低服务器压力，诞生了 HTTP 缓存，不过 HTTP 缓存仍有一定的局限性：体系较为复杂、需要服务器支持、通常难以及时更新等……  而通过 Service Worker 进行本地缓存就能解决上述的很多痛点：\nsw 的缓存体系非常简单，就是拦截用户请求然后使用 Cache API 读写缓存。\nsw 完全不依赖服务器实现，只要提供给用户 sw 的 js 文件，DOM 中添加相关支持，即可体验完整的功能。\n  但是 Service Worker 整体有一定的复杂度，且使用简单的实现仍然无法解决无法及时更新缓存的问题，此时 swpp 就派上了用场。  swpp 通过增量更新，在构建网站时扫描需要缓存的内容，确定本次更新需要更新哪些缓存，客户端就可以主动使这些缓存失效，从而解决缓存无法及时更新的问题。  swpp 同时支持按时间过期和永久缓存两种缓存方式，两种方式都可以使用增量更新。","缓存大小限制和预缓存#缓存大小限制和预缓存":"预缓存是指在网站加载时，预先缓存一些用户可能使用的资源。该功能妥善使用的话可以优化用户体验，但是为了避免用户滥用，swpp 没有内置该功能。  swpp 目前没有内置对缓存大小限制和预缓存的支持代码，但是用户可以通过自己配置，轻松实现这一功能。","request-篡改和-204-阻塞响应#Request 篡改和 204 阻塞响应":"启用 sw 后一个请求的流程为：DOM 端发送请求 -> SW 端拦截并处理请求 -> SW 端发送网络请求或直接返回。  swpp 允许用户在 SW 端修改请求的内容，相当于一个本地的加强版重定向，同时也可以选择直接在 SW 阻塞掉某个请求。","url-竞速和备用-url#URL 竞速和备用 URL":"对于 npm cdnjs 或 github 之类平台上的资源，通常有多个 CDN 可用。  通过 URL 竞速，可以同时拉取这些 CDN 上的文件，然后取响应速度最快的一个作为最终结果。  而通过备用 URL，则可以优先访问原始的 URL，如果响应超时或失败，则同时拉取剩余 CDN 上的文件，然后取响应速度最快的一个作为最终结果。","逃生门#逃生门":"swpp 的缓存增量更新需要 DOM 端发送消息到 SW 端，如果 DOM 端实现错误导致无法发送消息且 DOM 端代码被永久缓存，那么靠普通手段是完全没有办法解决这个死循环的，逃生门的作用就是触发时强制更新缓存来解开这个死局。"}},"/features/fetch":{"title":"关于网络请求","data":{"":"swpp 默认的 fetch 工作流程如下：","关于缓存#关于缓存":"对于使用了 CDN 的同学，网站结构大致如下：","cdn-缓存#CDN 缓存":"CDN 缓存是用户访问 CDN 时，若指定的资源不在 CDN 中存在，则会从源站中拉取资源，然后缓存到 CDN 的服务器当中，下一次用户再次访问同一个资源时，就不需要再访问源站了。  对于使用 CDN 的同学，这个功能推荐启用，可以降低源站压力、提高网站响应速度。","存在的问题#存在的问题":"目前 CDN 的缓存一般是每个文件独立计时的，那么通过 CDN 拉取文件时就有可能出现一部分的文件是最新的，而一部分文件是未更新的结果。  如果此时客户端拉取到的其它文件是新的，而版本文件是旧的，那么就会导致版本文件的 CDN 缓存更新时，把不需要更新的内容又重复地更新了一遍。  如果此时客户端拉取到的版本文件是最新的，而其它文件是旧的，那么就会导致这部分资源无法被及时更新，同时如果这个资源您是使用永久缓存的方式存储的，那么直到手动更新或下一次版本更新前，其将永远不会被更新。  为了解决这个问题，可以从以下方案里面选择：\n把所有文件的 CDN 缓存时间拉到最长，每次更新网站后刷新 CDN 的所有缓存\n把所有文件的 CDN 缓存时间拉到最长，每次更新网站后刷新需要刷新的资源的 CDN 缓存\n选择支持同步不同资源缓存时间的 CDN\n对于需要本地缓存的资源不使用 CDN 缓存（不推荐）\n不使用 CDN（不推荐）"}},"/":{"title":"Service Worker Plus Plus","data":{"什么是-swpp#什么是 swpp":"swpp 是一个用于为网站快速生成一个高度可用的 Service Worker 的工具，旨在提高网站的可靠性、优化二次访问性能、提供离线浏览功能……  常用 SW 构建工具的对比：\n\tswpp@3\tswpp@2\thexo-offline\t本地缓存\t✔️\t✔️\t✔️\t缓存增量更新\t✔️\t✔️\t❌\t缓存过期时间\t✔️\t❌\t✔️\t缓存大小限制\t❌\t❌\t✔️\t预缓存\t❌\t❌\t✔️\tRequest 篡改\t✔️\t✔️\t❌\tURL 竞速\t✔️\t✔️\t❌\t备用 URL\t✔️\t✔️\t❌\t204 阻塞响应\t✔️\t✔️\t❌\t逃生门\t✔️\t✔️\t❌\t请求合并\t❌\t✔️\t❌\t高度自由\t✔️\t✔️\t❌\t更新\t活跃\t停止维护\t超过两年没有更新","swpp-v2-与-v3-的区别#swpp v2 与 v3 的区别":"swpp v3 对 swpp 的所有代码进行了完全的重构，现在代码逻辑更加的清晰。除了后台代码的差异，v3 还有以下一系列的改进：\n完全定制化\n现在您对 swpp 生成的 sw 拥有完全的控制权。在 v2 中，如果需要修改插件生成的 sw 的逻辑，您需要自行编写整个 sw 文件。\nv3 中将 sw 文件的各个部分拆分到了环境变量中，这使得您可以通过配置文件覆盖 sw 文件中的任意一个部分，或者追加任意内容。\n现代化配置\n现在您可以使用 ts 语言编写配置文件，同时还可以选择使用 ESM。在 v2 中您必须使用 CommonJS。\n同时使用内置的一系列 define 函数可以让您对配置的颗粒度进行更加完美的掌控。\n完善的类型\n现在 swpp 提供了更加优雅的数据类型，以优化编写配置项、二次开发时的体验。","约定#约定":"在正式开始前您需要知道下面的事：\n本文档统一使用 npm 指令，您可根据喜好替换为自己使用的命令。\n在使用 swpp 之前您应当具备 ts/js 的部分知识，否则您可能会遇到一些麻烦。\nswpp 分为前后端实现，如不特别声明，均指后端实现。本文档是后端实现的文档。\n文档中的示例代码中出现的 // noinspection xxx 注释用于在编写文档时消除 IDE 警告，不需要 CV 走。","版本号#版本号":"目前 swpp v3 还在测试阶段，版本号全部采用 3.0.0-alpha.<a><b><c> 的格式：\n3.0.0 - 大版本号\nalpha - 测试版本\na - 一级子版本号，变动时表明 API 或配置文件等内容发生了不向前兼容的变动\nb - 二级子版本号，变动时表明添加了新的功能\nc - 三级子版本号，变动时表明进行了漏洞修复\n  当 a b c 的某一位达到两位数时，会在其中添加 x 表示分割。","历史文档#历史文档":"本文档不保存历史版本，因为本人永远推荐用户使用最新版的 swpp，旧版的 swpp 很可能是不安全的。","qq-群#QQ 群":"注意：swpp 有且仅有下面的群是官方的："}},"/qa":{"title":"Qa","data":{"":"在本页中，将列出常见的问题及对应的解决方案或建议。","未知函数-fetch#未知函数 fetch":"运行时报错：ReferenceError: fetch is not defined。  解决方案：\n更新 NodeJS 版本（推荐）\n自行编写使用其它拉取方法实现的函数替代 swpp 内置的实现","本地预览前端出现-404#本地预览前端出现 404":"本地预览时，前端会报错找不到 xxxx.json，这是由于部分前端实现不会在本地预览时构建 swpp 的 json 文件，所以产生了报错，直接无视即可。"}},"/quickstart":{"title":"在您的项目中快速添加 swpp 支持","data":{"":"在本章之中，您将了解如何安装、使用 swpp。","结构介绍#结构介绍":"swpp 将实现分为了前端实现和后端实现，其中后端实现是唯一的，而前端实现在不同平台会有不同的实现。  swpp 对前端的具体实现没有太多限制，所以前端实现的安装、使用方法请阅读其提供的文档。下文中将为您介绍后端的安装、使用方法。  下面是已知的前端实现：\n平台\t插件名\t文档\t作者\thexo\thexo-swpp\tgithub\t空梦","安装#安装":"在项目中安装 swpp 后端非常简单，只需要运行下面的指令即可：\nnpm install swpp-backends@3","创建配置文件#创建配置文件":"swpp 支持以下类型的配置文件：ts js mts cts mjs cjs。  配置文件的文件名及所在路径请见您使用的前端实现的文档，此处我们假设配置文件名称为 swpp.config.ts。  接下来需要在其中填入下面的内容（注意将 DOMAIN_HOST 替换为您的 host）：\nimport { defineConfig } from 'swpp-backends';\ndefineConfig({\n    compilationEnv: {\n        // 此项是必须配置的项目，swpp 必须知道您的域名才能区分哪些资源是外部资源。\n        // 部分前端实现可能会帮您自动填写该项目，具体是否必须手动填写请见前端实现的文档。\n        DOMAIN_HOST: new URL('https://www.example.com')\n    }\n})\n  此时您就完成了配置 swpp 所必须的步骤。","注意事项#注意事项":"swpp 生成的 Service Worker 文件中的代码未经压缩，会包含很多无用字段，所以会非常臃肿，请注意使用压缩器压缩 js 的内容。\n目前 swpp v3 还处于测试阶段，所以请注意留意启用 swpp 后网站是否会工作异常（尤其是与缓存功能相关的）。\n请注意追进 swpp 的版本更新。"}},"/quickstart/cli":{"title":"通过 CLI 指令构建","data":{"":"如果您使用的平台不是 NodeJs 或框架没有专门支持 swpp 的包，那么可以使用 CLI 指令构建 swpp 内容，但是通过 CLI 构建 swpp 相比于使用专门适配框架的软件包要麻烦一些，需要运行指令才能在本地预览 Service Worker。","安装#安装":"运行下面指令即可完成安装：\nnpm install swpp-backends@3\nnpm install swpp-backends@3 -g","配置-cli#配置 CLI":"您需要在项目的某一个位置创建 CLI 的配置文件，默认路径是：./swpp.cli.json（路径相对于运行指令的位置），您可以通过指令修改该路径。然后在其中填写如下内容：\n{\n  \"webRoot\": \"这里填发布目录\",\n  \"configFiles\": [\n    \"这里填 js/ts 配置文件的相对路径（绝对路径也可以，但是推荐相对路径）\"\n  ]\n}\n  配置项的具体解释如下（?: 表示可选，: 表示必填）：\nexport interface SwppCliConfig {\n    /** 网站根目录（就是存放最终生成的 html、css 等文件的目录）的绝对或相对路径 */\n    webRoot: string\n    /** 配置文件所在的相对路径（越靠前优先级越高） */\n    configFiles: string[]\n    /** dom js 的相对路径（相对于网站根目录，以 `/` 开头 `.js` 结尾），默认值为 `/sw-dom.js` */\n    domJsPath?: string\n    /**\n      * 需要被排除的 html 文件名，正则表达式。\n      * 如果部分 html 文件不需要在其中插入 <script>，那么在这里可以填写正则表达式忽略这些文件，区分大小写。\n      * 默认为空。\n      */\n    excludes?: string[]\n    /** 是否生成 sw 文件。默认为 true */\n    serviceWorker?: boolean\n    /** 是否向 HTML 中插入注册代码。默认为 true */\n    auto_register?: boolean\n    /** 是否自动生成 DOM JS 并在 HTML 插入 <script>。默认为 true */\n    gen_dom?: boolean\n    /**\n      * diff json 的相对路径（相对于项目根目录）或绝对路径（以 .json 结尾）。\n      * 该文件当中存储本次构建更新的缓存的列表。\n      * 留空表示不生成，该项用于辅助用户使用脚本自动刷新 CDN 缓存。\n      */\n    diffJsonPath?: string\n}","指令#指令":"您可以运行 swpp-cli -h 指令获取帮助信息，下面是一些常用的指令：\nswpp-cli -v: 查看版本\nswpp-cli -b: 构建 swpp\n  在构建 swpp 时，您可以通过添加 --prod 来将构建模式切换到生产模式，否则为开发模式。","创建-swpp-配置文件#创建 swpp 配置文件":"在项目根目录下创建 swpp.config.ts 文件（您可以通过 json 配置修改配置文件所在的路径）。  CLI 不会自动为您填写配置文件中的 DOMAIN_HOST 字段，所以您需要手动填写该字段。  到这里您就完成了 swpp 安装的所有流程，但是此时您尚未启用 swpp 的任何功能，所以并不能给您的网站带来任何改善，继续阅读文档以了解 swpp 的配置项。"}},"/quickstart/hexo":{"title":"在 Hexo 中使用 swpp","data":{"":"在本章中，您将了解如何在 hexo 中使用 swpp。","安装#安装":"首先，运行下面的指令安装插件：\nnpm install swpp-backends@3 hexo-swpp@4\n  当 swpp-backends 存在版本更新时，可以直接更新 swpp-backends 版本，不需要更新 hexo-swpp 的版本。（不过 hexo-swpp 有更新的话最好也跟进一下。）","配置-hexo-swpp#配置 hexo-swpp":"接下来，您需要在 hexo 配置或主题配置文件中写入下面的内容：\nswpp:\n  # 是否启用，默认 false\n  enable: true\n  # 配置文件路径，以 `/` 结尾表示加载指定文件夹下的所有文件，注意文件夹中只能有配置文件，不能有其它文件及文件夹\n  # config_path: 'swpp.config.ts'\n  # 是否生成 sw\n  # serviceWorker: true\n  # 是否向所有 HTML 插入注册 sw 的代码\n  # auto_register: true\n  # 是否生成 DOM 端的 JS 文件并在 HTML 中插入 script\n  # gen_dom: true\n  # 生成的 diff 文件的路径（可以是绝对路径也可以是相对路径，使用相对路径时相对于网站发布目录），留空表示不生成（默认为 null）\n  # gen_diff: './diff.json'\n  # 是否在执行 hexo deploy 时自动执行 swpp 指令\n  # auto_exec: false\n  # 检查更新的网址，默认 \"https://registry.npmjs.org\"，注意不能以斜杠结尾\n  # npm_url: 'https://registry.npmmirror.com'\n  #\n  # 排序规则。\n  # sort_rules:\n  # 该配置项是为了对 hexo 中的一些变量进行排序，避免每次生成 HTML 时由于这些变量的顺序变动导致生成结果不完全相同。\n  # 下面给出的值为插件的缺省值，用户设置该项不会直接覆盖这些值，只有用户也声明 posts、pages 或 tags 时才会覆盖对应的值。\n  # 其中 key 值为要排序的变量的名称，value 为变量排序时的依据，\n  # 填 false 表示禁用该项排序，填 true 表示以 value 本身为键进行排序，填字符串表示以 value[tag] 为键进行排序。\n  # sort_rules:\n  #   posts: 'title'\n  #   pages: 'title'\n  #   tags: 'name'\n  插件会在生成网站时自动生成 Service Worker、注册代码、DOM 端支持代码，版本更新文件需要通过 hexo swpp 命令手动生成。  auto_exec 配置项允许用户在执行 hexo deploy 指令时自动执行 hexo swpp 的内容（注意开启该配置项后无法再使用 hexo swpp 命令）。⚠ 注意：\n尽可能在压缩网站内容前执行 hexo swpp，因为部分压缩插件可能会出现同样的内容连续压缩结果不一样的问题，这会导致插件错误地更新缓存。\n如果你的网站发布过程不使用 hexo deploy 指令，则不要启用 auto_exec 选项。\n将 npm_url 调整为非官方 URL 后检查版本时可能会出现 404 错误。","指令#指令":"hexo swpp - 构建 json 文件\nhexo swpp -b / hexo swpp --build - 构建 json 文件，同 hexo swpp\nhexo swpp -t [URL] / hexo swpp --test [URL] - 尝试拉取指定 URL，使用时将 [URL] 替换为有效的 HTTP/HTTPS 链接（需要附带协议头）","创建-swpp-配置文件#创建 swpp 配置文件":"在项目根目录下创建 swpp.config.ts 文件（您可以通过 yaml 配置修改配置文件所在的路径）。  hexo-swpp 会根据 hexo 配置自动为您填写配置文件中的 DOMAIN_HOST 字段，所以您无需手动填写该字段。  hexo-swpp 在 globalThis 中写入了 hexo: Hexo 变量，您可以直接访问 hexo 的数据。  到这里您就完成了 swpp 安装的所有流程，但是此时您尚未启用 swpp 的任何功能，所以并不能给您的网站带来任何改善，继续阅读文档以了解 swpp 的配置项。"}},"/config":{"title":"配置文件的详细说明","data":{"":"本章将带您了解 swpp 的配置文件的组成，以及对 swpp 内置的所有配置项的解释说明。","环境#环境":"无论您是使用 js 还是 ts 编写配置文件，配置文件都将与主体程序共享同一个运行环境，也就是说配置文件中的代码可以访问到主体程序提供的 globalThis 等全局数据。  简单来说就是 swpp 会使用类似于 require('xxx/xxx/xxx') 的方式加载配置文件，所以相当于您在当前的项目中又编写了一个代码文件。  知道了这个，就可以在配置文件中进行一些“骚操作”，即可以动态地修改环境中的一些内容。但是 swpp 并不建议这么做，配置文件在设计上用于修改、调整 swpp 的一些行为，如果您确实需要运行一段有副作用的代码，建议优先通过其它更合理的办法进行。  swpp 会在加载配置时执行配置文件中的代码，如果您在配置文件顶层抛出了异常，那么将会导致配置加载失败，具体会产生什么后果视前端的具体实现而不同，可能会使整个程序直接结束，也可能只终止 swpp 的任务。  因为配置文件共享主程序的 package.json，所以配置文件中可以使用所有主程序中安装的依赖（包括 swpp 本身）。","修改配置的方法#修改配置的方法":"swpp 中统一使用 defineXxx 函数定义配置，其中 defineConfig 用于一次性定义所有配置，其余 defineXxx 用于定义某一个分类下的配置。  非常需要注意的是，配置文件中必须在加载完毕前调用 define 系列函数，否则将会导致错误，所以在异步任务中调用 define 是非常危险的操作。对于 js/ts 功底不好的同学来说，您只需要记住 define 系列的函数必须在顶层调用即可（可以嵌套在 if 等语句中）。\n  下面是一段示例代码，其中列出了 swpp 内置的所有可调节配置分类：\nimport {defineConfig} from 'swpp-backends'\ndefineConfig({\n    compilationEnv: {},\n    crossEnv: {},\n    runtimeDep: {},\n    crossDep: {},\n    runtimeCore: {},\n    runtimeEvent: {},\n    domConfig: {},\n    compilationFileParser: {},\n    modifier: {}\n})\n  下面是一段示例代码，其中列出了 swpp 内置的所有可调节配置分类：\nimport {\n    defineCompilationEnv, defineCompilationFP,\n    defineCrossDep, defineCrossEnv,\n    defineDomConfig, defineModifier,\n    defineRuntimeCore, defineRuntimeDep, defineRuntimeEvent\n} from 'swpp-backends'\ndefineCompilationEnv({})\ndefineCrossEnv({})\ndefineRuntimeDep({})\ndefineCrossDep({})\ndefineRuntimeCore({})\ndefineRuntimeEvent({})\ndefineDomConfig({})\ndefineModifier({})\n  注意：上面的示例中一次性列出了所有的分类，实际使用时，建议只写出需要修改的配置，以保持配置文件的简洁性。","配置分类与命名规则#配置分类与命名规则":"从上面的示例代码中可以看到，swpp 将内置的配置项分为了八类，其命名规则如下：\ncompilation 开头表示该分类下的配置仅在构建时产生影响，不会被写入到 sw 文件中。\nruntime 开头表示该分类下的配置仅会被写入到 sw 文件中，不会在构建时被使用。\ncross 开头表示该分类下的配置在构建时有可能被使用，同时会被写入到 sw 文件中。\ndom 开头表示该分类下的配置会影响 DOM 端 js 的生成。\nmodifier 是一项非常特殊且功能强大的配置，后面将会专门进行讲解。","运行顺序#运行顺序":"swpp 会按照如下顺序装配配置：\n按优先级将配置文件加载到内存（优先级越高越先加载）\n调用 modifier#build 函数构建各个 KV 库（没有 build 则将使用默认实现）\n调用 modifier#registry 函数（优先级越低越先执行）\n依次将 runtime compilation 和 cross 的配置写入到 KV 库当中\n调用 modifier#dynamicUpdate 函数\n冻结所有 KV 库","配置优先级#配置优先级":"不同配置文件的优先级依据前端的实现不同而不同，同一个配置文件中越早调用的 define 函数优先级越高。"}},"/config/runtime_core":{"title":"运行时核心代码","data":{"":"该配置项用于放置所有核心功能函数，用法与 运行时函数依赖 相同。  该配置项与运行时函数依赖不同的是两者的定位，函数依赖中主要放置一些简单的工具函数，而运行时核心代码则放置一些核心代码。 默认情况下，核心代码也将被插入到函数依赖的后面，在一些特殊情况下可以避免一些声明顺序导致的问题。  请注意：除非您知道您在做什么，否则不要修改该分类下的内容！！！","handleescape#handleEscape":"类型\t说明\t() => Promise<void>\t逃生门的实现\t\n  该项用于实现逃生门，默认实现如下：\n// noinspection TypeScriptUnresolvedReference\nasync (): Promise<void> => {\n    const oldVersion = await readVersion()\n    if (ESCAPE && oldVersion && oldVersion.escape !== ESCAPE) {\n        await caches.delete(CACHE_NAME)\n        await postMessage('escape', null)\n    }\n}\n// 消除 IDE 报错\nlet readVersion: () => Promise<BrowserVersion | undefined>\nlet ESCAPE: number\nlet CACHE_NAME: string","handleupdate#handleUpdate":"类型\t说明\t(oldVersion: BrowserVersion | undefined, force?: boolean) => Promise<1 | -1 | 2 | undefined | null | void | string[]>\t增量更新功能\t\n  具体实现 参照源码，该函数参数及返回值的解释如下：\noldVersion: 更新前客户端的版本号。\nforce: 是否强制更新，为 false 时如果两次更新的时间小于阈值，则不会进行更新。\nreturn: 标记缓存是否更新，-1 表示新访客，1 标记仅更新版本号，2 表示更新了缓存，string[] 表示更新了部分缓存，否则表示没有进行任何更新。","handlefetchevent#handleFetchEvent":"类型\t说明\t(event: FetchEvent) => any\t处理网络请求事件\t\n  具体实现 参照源码。"}},"/config/modifier":{"title":"动态修改器","data":{"":"动态修改器用于在各个阶段执行特定的任务，不同配置文件中的修改器不会相互覆盖。  您可以通过下面的代码定义并导出一个修改器：\nimport {defineModifier} from 'swpp-backends'\ndefineModifier({\n})","build#build":"build 函数用于将 swpp 内部使用的 RuntimeData 和 CompilationData 替换为您的实现，如果在多个配置文件中均定义了 build 函数，那么将只有优先级最高的 build 生效。  默认创建 RuntimeData 和 CompilationData 的代码如下：\n// noinspection TypeScriptUnresolvedReference\n() => {\n    const compilation = new CompilationData()\n    const runtime = new RuntimeData(compilation)\n    return {runtime, compilation}\n}\n  您可以通过定义 build 函数来让 swpp 使用您的实现：\n// noinspection TypeScriptUnresolvedReference\nimport {defineModifier} from 'swpp-backends'\ndefineModifier({\n    build: () => {\n        // do something\n        return {\n            runtime: xxx,\n            compilation: xxxx\n        }\n    }\n})","registry#registry":"如果您在看到这里之前尝试向环境变量中写入您自己定义的值，您会发现在运行时将会产生错误，因为 swpp 为了避免您出现拼写错误，不允许向配置中写入不存在的键。  registry 的作用就是向环境变量中注册新的键（该函数内应当只调用 xxx.append 函数及其它工具函数，非必要不应当包含其它有副作用的操作），优先级越低该函数越早执行：\n// noinspection TypeScriptUnresolvedReference,JSUnusedLocalSymbols\nimport {defineModifier} from 'swpp-backends'\ndefineModifier({\n    registry: (runtime: RuntimeData, compilation: CompilationData) => {\n        runtime.crossEnv.append('your_key', {\n            // 使用 default 定义缺省值\n            default: 'default value',\n            // 可选项：通过 checker 检查配置项中填入的值（或缺省值）是否合法\n            // 合法返回 false，否则返回 RuntimeEnvErrorTemplate<T>，也就是 { value: T, message: string }\n            // 此处实际为一个泛型，value 的类型与 default 是同一个类型\n            // 您不需要在 checker 中检查 value 的类型是否与 default 相同，swpp 会在调用 checker 之前自动判断\n            checker(value: string): false | RuntimeEnvErrorTemplate<T> {\n                if (!value) return {\n                    value, message: 'your_key 不能为空'\n                }\n                return false\n            }\n        })\n    }\n})","dynamicupdate#dynamicUpdate":"本函数用于动态修改属性的值，函数内应当只调用 xxx. update 函数及其它工具函数，非必要不应当包含其它有副作用的操作，优先级越低该函数越早执行：\n// noinspection TypeScriptUnresolvedReference\nimport {defineModifier} from 'swpp-backends'\ndefineModifier({\n    // 这个示例的功能是在配置中填写的有 `key_a` 后修改 `key_b` 的值\n    dynamicUpdate: (runtime: RuntimeData, compilation: CompilationData) => {\n        if (runtime.crossEnv.hasValue('key_a')) {\n            compilation.compilationEnv.update('key_b', 'key_a has value')\n        }\n    }\n})"}},"/config/special":{"title":"配置工具介绍与应用","data":{"":"细心的朋友会发现除了前文提到的一系列 defineXxx 函数外，还有一些 define 打头的函数没有提到，这些函数是一些方便用户进行个性化配置的一些工具函数。  这些工具函数构建的配置项有两大分类：SpecialConfig 和 RuntimeSpecialConfig，其中 RuntimeSpecialConfig 从前者派生。  从名字很容易可以看出来，RuntimeSpecialConfig 的生命周期要更长一些，实际上也正是如此，SpecialConfig 的生命周期为构建配置到配置完成导入，而 RuntimeSpecialConfig 的生命周期会从构建配置持续到 swpp 结束运行。  这一系列函数的用法非常简单：\nimport {defineConfig, defineXxx} from 'swpp-backends'\n// noinspection TypeScriptUnresolvedReference\ndefineConfig({\n    runtimeDep: {\n      // 注意这些工具函数可以也只能在配置项名称后方使用\n      example: defineXxx(...args)\n    }\n})\n  ⚠️注意：如非特别声明，这些 define 函数不能嵌套使用。","不可分割配置#不可分割配置":"继承关系：IndivisibleConfig <- SpecialConfig  默认情况下，swpp 会对产生冲突的配置项按照优先级进行合并，当定义一个对象配置时，将允许从其它配置文件中合并一部分配置到对象中，比如：\nimport {defineXxx} from 'swpp-backends'\n// 当前配置\ndefineXxx({\n    value: {\n        example1: 'hello world'\n    }\n})\n// 如果还有一个配置文件中也声明了这个配置\ndefineXxx({\n    value: {\n        example2: 'hello swpp'\n    }\n})\n// 最终将合并生成如下配置\n// value: {\n//     example1: 'hello world',\n//     example2: 'hello swpp'\n// }\n  该函数用于定义一个无法分割的对象配置，这对一些强依赖对象内部属性的设置很有用，可以避免对象被错误地拼接。  通过该函数，可以禁止 swpp 合并配置时仅选取对象的部分字段，要么全部使用 [value] 的值，要么完全不使用 [value] 的值。  放入到上述例子中，假如两个对象中任意一个或多个通过 defineIndivisibleConfig({ xxx: xxx }) 设置，最终的值将取决于两个配置文件的优先级， 若 example1 的优先级高将产生：\nimport {defineXxx, defineIndivisibleConfig} from 'swpp-backends'\n// 当前配置\ndefineXxx({\n    value: defineIndivisibleConfig({\n        example1: 'hello world'\n    })\n})\n// 如果还有一个配置文件中也声明了这个配置\ndefineXxx({\n    value: {\n        example2: 'hello swpp'\n    }\n})\n// 最终将合并生成如下配置\n// value: {\n//     example1: 'hello world'\n// }\n  注意事项：\n仅有在两个对象中存在使用 defineIndivisibleConfig 定义的配置时才会禁用配置合并，假设现在有 A > B > C 三个配置项都产生了冲突，其中 A 优先级最高，但是只有 C 使用了 defineIndivisibleConfig，那么 A 将与 B 完成合并后再与 C 进行尝试合并，由于 C 不能分割且优先级低，所以最终将产生 A 与 B 合并后的结果。\n如果次级配置文件中使用 defineIndivisibleConfig 定义了某项配置，如果您需要覆盖这个配置，注意您无法使用这个配置中的内容，需要手动重写整个配置项。\n除 IndivisibleConfig 外，所有的 RuntimeSpecialConfig 都会携带与 IndivisibleConfig 相同的副作用。","上下文配置#上下文配置":"继承关系：ContextConfig <- SpecialConfig  有些时候您可能希望在本地和远程环境使用不一样的配置，如果是大量的配置项不相同，那么您可以使用两个配置文件来编写配置，然后依靠前端实现来区分本地和远程的配置文件；如果是少量配置不相同，那么可以直接使用该函数来进行定义。\nimport {defineXxx, defineContextConfig, defineLazyInitConfig} from 'swpp-backends'\ndefineXxx({\n    example: defineContextConfig({\n        dev: 'hello dev',\n        prod: defineLazyInitConfig(() => 'hello prod')\n    })\n})\n  这样，example 在开发环境将是 hello dev，在生产环境将是 hello prod。  该配置项内可嵌套 RuntimeSpecialConfig。","不可缓存配置#不可缓存配置":"继承关系：NoCacheConfig <- RuntimeSpecialConfig <- SpecialConfig  默认情况下，swpp 会缓存配置项的结果，下一次读取同一个配置项时便不需要经过类型检查等操作。有些时候您可能希望每一次读取值时都动态读取，那么可以使用此方法禁用缓存。  注意：该选项禁用缓存后对于性能有些许影响，计算结果和校验的成本越高影响越大，一般情况下无显著影响。  对于下方这个例子，第一种写法每次读取该项配置时，结果都将相同，如果第一次为 123456 那么以后永远都将是 123456；而对于第二种写法，则每次调用时都能动态地获取当前系统时间。\nimport {defineXxx, defineNoCacheConfig} from 'swpp-backends'\n// config 1\ndefineXxx({\n    example: Date.now()\n})\n// config 2\ndefineXxx({\n    example: defineNoCacheConfig(() => Date.now())\n})","延迟初始化配置#延迟初始化配置":"继承关系：LazyInitConfig <- RuntimeSpecialConfig <- SpecialConfig  默认情况下，swpp 会在加载配置文件时对各项配置的值进行计算，此时就出现了一个问题，您无法在设置配置时访问其它配置内容。  如果您希望能够延后计算配置项的值以访问其它配置项，则可以使用该函数定义配置。  例：\n// noinspection TypeScriptUnresolvedReference,JSUnusedLocalSymbols\nimport {defineXxx, defineLazyInitConfig} from 'swpp-backends'\ndefineXxx({\n    example: defineLazyInitConfig((runtime, compilation) => {\n        // 这里的代码将在第一次读取配置时执行\n        // do something\n        return _result\n    })\n})"}},"/config/runtime_dep":{"title":"运行时函数依赖","data":{"":"该配置项用于放置所有仅在浏览器 SW 环境下执行的工具函数。  对于每一项配置 <KEY>: <function>：<KEY> 是函数名（推荐使用小写驼峰式命名），<function> 是函数体。  如果函数体中需要使用其它运行时的环境变量、函数依赖等内容，直接调用即可，如果需要避免 IDE 报错/ 警告，可以在配置文件中声明一些不导出的变量，以此假装上下文中存在该函数。 TS 还可以使用 @ts-ignore 忽略相关的错误。  例：\nimport {defineRuntimeDep} from 'swpp-backends'\n// 该代码将在 sw. js 中创建一系列函数：\n// const example = () => console. log('hello')\n// function invokeExample() {\n//     example()\n// }\ndefineRuntimeDep({\n    example: () => console. log('hello'),\n    invokeExample: function() {\n        example()\n    }\n})\n// 如果为了避免 IDE 报错，还可以在文件任意一个位置编写类似的代码：\n// let example: () => void       good\n// let example = any             不推荐，因为丢失了类型，会影响 IDE 的自动补全和静态类型推断\n// 或者直接在函数调用的位置使用 @ts-ignore 也可以避免报错，同样不推荐，理由同上\nlet example: () => void // 这行代码用来消除 IDE 警告","matchfromcaches#matchFromCaches":"类型\t说明\t(request: RequestInfo | URL) => Promise<Response |undefined>\t尝试匹配一个缓存\t\n  该项用于从缓存库中读取一个缓存，默认使用 Cache API。","writeresponsetocache#writeResponseToCache":"类型\t说明\t(request: RequestInfo | URL, response: Response, date?: boolean) => Promise<void>\t写入缓存\t\n  该项用于向缓存写入或更新一条数据，默认实现如下：\n/**\n  * @param request 请求信息\n  * @param response 响应体\n  * @param date 是否存储时间戳\n  */\nasync (request: RequestInfo | URL, response: Response, date?: boolean) => {\n    if (date) {\n        // 如果需要存储时间戳就新建一个 Response 并写入新的 header\n        const headers = new Headers(response.headers);\n        headers.set(STORAGE_TIMESTAMP, new Date().toISOString());\n        response = new Response(response.body, {\n            status: response.status,\n            headers\n        });\n    }\n    const cache = await caches.open(CACHE_NAME);\n    await cache.put(request, response);\n};\n// 用于消除 IDE 报错，值在其它配置项中插入到 SW\nlet CACHE_NAME: string\nlet STORAGE_TIMESTAMP: string","markcacheinvalid#markCacheInvalid":"类型\t说明\t(request: RequestInfo | URL) => Promise<void>\t标记一个缓存为失效缓存\t\n  swpp 默认使缓存失效的方法是在响应体当中写入一个 特定的 header，当尝试使用这个缓存时，检查缓存是否过期，如果过期则尝试从网络拉取最新内容。  如果需要的话您可以通过自定义 markCacheInvalid 和 isValidCache，将缓存失效方法改为立即删除。","isvalidcache#isValidCache":"类型\t说明\t(response: Response, rule: number) => boolean\t判断缓存是否有效\t\n  该项用于判断一个缓存是否还有效，返回 true 将直接使用这个缓存，否则将尝试拉取新的值。  其中第二个参数是缓存的过期时间，若为负表明该缓存没有过期时间，为正时单位为毫秒，不可能为零。  如果您想要将缓存失效方法改为立即删除可以使用如下配置：\nimport {defineRuntimeDep} from 'swpp-backends'\ndefineRuntimeDep({\n    markCacheInvalid: (request: RequestInfo | URL) =>\n        caches.open(CACHE_NAME).then(cache => cache.delete(request)),\n    isValidCache: () => true\n})\nlet CACHE_NAME: string","readversion#readVersion":"类型\t说明\t() => Promise<BrowserVersion | undefined>\t读取客户端版本号\t\n  该项用于读取客户端当前的版本号，默认实现使用 matchFromCaches 读取。","writeversion#writeVersion":"类型\t说明\t(version: BrowserVersion) => Promise<void>\t更新客户端版本号\t\n  该项用于设置客户端当前的版本号，默认实现使用 writeResponseToCache 实现。  注意：如果您需要自定义该项目，务必在写入缓存前，为传入的 version 中的 tp 字段赋值：version.tp = Date.now()。","postmessage#postMessage":"类型\t说明\t(type: string, data: any, ...goals: Client[]) => Promise<void>\t向指定客户端发送消息\t\n  该配置项用于向指定的客户端发送消息，其中各个变量解释如下：\ntype: 消息类型\ndata: 消息内容\ngoals: 客户端对象，若该项传入了一个空的数组，表明向所有客户端发送消息","isfetchsuccessful#isFetchSuccessful":"类型\t说明\t(response: Response) => boolean\t检查一个请求是否成功\t\n  该项用于通过 Response 检查拉取是否成功，默认通过状态码判断（若状态码返回 200 301 302 307 308 会被视为成功）。  请注意！！！缓存、URL 竞速、备用 URL 等功能均会使用该函数判断某个请求是否成功，返回错误地返回 true 或 false 会导致功能异常：\n对于缓存：若错误地返回了 true 会导致将失败的响应缓存到本地，若错误地返回了 false 将会导致结果不被缓存。\n对于 URL 竞速和备用 URL：若错误地返回了 true 会导致将一个失败的响应视为成功响应作为最终的响应结果；若错误地返回了 false 会错失正确的响应，可能导致最终响应失败。\n  部分 CDN 响应错误时不使用状态码进行标记，而是使用响应体中的内容，此时有下面几种解决方案：\n避开该 CDN，使用其它 CDN 进行替代\n对于该 CDN 的资源不启用缓存等功能\n自定义 isFetchSuccessful，在函数中读取响应体的数据判断请求是否成功。\n需要特别注意的是，如果需要在该函数中读取 body，请先克隆响应体，然后读取克隆后的结果，否则会导致后续的流程无法读取响应体内容。","fetchwrapper#fetchWrapper":"类型\t说明\t(request: Request, banCache: boolean, cors: boolean, optional?: RequestInit) => Promise<Response>\t从网络拉取文件\t\n  一般不需要覆盖，默认实现如下：\n/**\n  * @param request 请求信息\n  * @param banCache 是否禁用 HTTP 缓存\n  * @param cors 是否启用 cors，填 false 使用 no-cors 模式\n  * @param optional 请求配置\n  */\n(request: Request, banCache: boolean, cors: boolean, optional?: RequestInit): Promise<Response> => {\n    const init: RequestInit = {\n        referrerPolicy: request.referrerPolicy ?? '',\n        ...optional\n    }\n    init.cache = banCache ? 'no-store' : 'default'\n    if (cors) {\n        init.mode = 'cors'\n        init.credentials = 'same-origin'\n    }\n    return fetch(request, init)\n}","iscors#isCors":"类型\t说明\t(request: Request) => boolean\t判断一个资源是否使用 cors\t\n  该项用于判断一个资源是使用 cors 还是 no-cors 模式，返回 true 表示使用 cors 模式，否则表示使用 no-cors。默认永远返回 false。  由于 no-cors 模式下 swpp 无法读取响应体中的状态码，所以对于需要应用缓存、URL 竞速、备用 URL 的请求，全部强制使用 cors 模式。","getfastestrequests#getFastestRequests":"类型\t说明\t(request: Request) => Request[] | undefined\t获取竞速列表\t\n  该项用于启用 URL 竞速，返回任意转换为 false 的值均表示对于给定的资源不启用 URL 竞速。  注意事项：\nswpp 会严格按照返回的数组中的内容进行并发请求，如果您返回的数组中不包含原有的 Request，swpp 将认为您希望跳过原有的资源地址。\n开启该功能后，会较为显著地增加网络压力、流量消耗和 CPU 压力。\n请勿滥用该功能（包括但不限于使用该功能实现类似于将网站部署到 NPM CDN 上的功能），这有违道德、容易被 CDN 封杀。\n自定义前请阅读：#isFetchSuccessful","getstandbyrequests#getStandbyRequests":"类型\t说明\t(request: Request) => {t: number, l: () => Request[]} | undefined\t获取备用列表\t\n  该项用于启用备用 URL，返回任意转换为 false 值均表示对于给定的资源不启用备用 URL。  对于返回值：\nt: 超时时间（毫秒），如果拉取原始 Request 的时间超过了这个时间，将会开始并发拉取备用 URL。\nl: 备用 Request 列表的 getter，设计成这样是避免在无需备用 URL 时生成列表占用 CPU、内存资源。\n  注意事项：\n返回的列表中不应当包含原始 Request，swpp 会先尝试访问原始 Request。\n应当把最可能成功、速度最快的链接设置为原始 Request，否则网站加载可能会出现比较大的延迟。\n自定义前请阅读：#isFetchSuccessful","fetchfastest#fetchFastest":"类型\t说明\t(list: Request[], optional?: RequestInit) => Promise<Response>\t通过竞速拉取文件\t\n  该项用于执行 URL 竞速的功能，默认实现已经能满足大部分需求，一般情况下无需覆盖。","fetchstandby#fetchStandby":"类型\t说明\t(request: Request, standbyRequests: {t: number, l: () => Request[]}, optional?: RequestInit) => Promise<Response>\t通过备用 URL 拉取文件\t\n  该项用于执行备用 URL 功能，默认实现已经能满足大部分需求，一般情况下无需覆盖。","fetchfile#fetchFile":"类型\t说明\t(request: RequestInfo | URL, optional?: RequestInit) => Promise<Response>\t从网络拉取文件\t\n  该项是对 URL 竞速和备用 URL 的封装，如果您启用了这两个功能中的至少一个，swpp 将自动为您生成合适的 fetchFile 函数。  一般情况下无需修改该项，您的修改会完全覆盖 swpp 原有的逻辑。若您修改了该项但没有手动调用 URL 竞速和备用 URL 的接口，即使设置了相关的属性功能也无法生效。  默认实现如下：\n// noinspection TypeScriptUnresolvedReference\nimport {defineLazyInitConfig} from 'swpp-backends'\n// 在这段代码中 fetchFastestAndStandbyRequests、fetchFastestRequests 和 fetchStandbyRequests 三者\n// 都是在 swpp 内部定义的三个函数，感兴趣的可以翻看 RuntimeDepCode.ts 源码\ndefineLazyInitConfig((runtime) => {\n    const runtimeDep = runtime.runtimeDep\n    const hasFastestRequests = runtimeDep.hasValue('getFastestRequests')\n    const hasStandbyRequests = runtimeDep.hasValue('getStandbyRequests')\n    if (hasFastestRequests && hasStandbyRequests) {\n        return fetchFastestAndStandbyRequests\n    } else if (hasFastestRequests) {\n        return fetchFastestRequests\n    } else if (hasStandbyRequests) {\n        return fetchStandbyRequests\n    } else {\n        return (request: RequestInfo | URL, optional?: RequestInit): Promise<Response> => {\n            // @ts-ignore\n            if (!request.url) request = new Request(request)\n            return fetchWrapper(request, true, true, optional)\n        }\n    }\n})","isblockrequest#isBlockRequest":"类型\t说明\t(request: Request) => boolean\t判断是否应当阻断请求\t\n  如果网站中存在需要屏蔽的请求，那么可以使用该功能阻断这些请求。若函数返回了 true，那么 swpp 将不再通过网络拉取文件，而是直接向上级返回 204 状态码的响应体。  注意：swpp 只能阻断网络请求，而无法阻止上游处理该请求的结果。","modifyrequest#modifyRequest":"类型\t说明\t(request: Request) => Request | null | undefined\t修改请求\t\n  如果您想要修改请求的内容，可以使用该功能返回一个新的 Request 以代替原始的 Request。  您可以修改 Request 中的任何内容，但是由于浏览器限制，您无法修改 referer 和 user-agent。  函数返回 Request 表示对当前资源启用该功能，返回任意转换为 false 的值表示禁用。"}},"/develop":{"title":"开发者指南","data":{"":"本章中我们将简单介绍如何为 swpp 进行平台适配。","依赖安装#依赖安装":"在 package.json 的 dependencies 中添加 swpp-backends 的依赖即可完成依赖的安装。  但是这种方法在 swpp-backends 更新时，平台实现也需要同步更新，使用起来不是特别方便，所以在这里我们推荐使用 peerDependencies。\nNPM 文档\n知乎中文介绍","平台适配#平台适配":"swpp 已经封装了大部分代码，进行适配时只需要线性调用接口即可，您可以参考 swpp-backends 中 cli.ts 和 hexo-swpp 的代码。  插件必要的初始化部分按照如下流程进行（部分流程之间无先后顺序）：\n初始化 swpp-backends 的配置（ConfigLoader）\n扫描网站的资源（ResourcesScanner）\n生成 sw 文件\n必要时修改已有的 HTML 文件\n将生成的内容写入到指定位置\n  下面我们介绍下常用的一些接口：","加载-swpp-配置#加载 swpp 配置":"加载配置相当简单，swpp-backends 已经将所有操作封装到了 ConfigLoader 当中，使用如下代码即可定义一个加载器：\nimport {ConfigLoader} from 'swpp-backends'\n// noinspection JSUnusedLocalSymbols\nconst loader = new ConfigLoader();\n  调用 ConfigLoader#load 即可读取指定配置，参数为配置文件（js 或 ts）的绝对路径，越早被加载的配置项优先级越高。  有些时候，您可能想要直接从代码中设置一些配置，则可以调用 ConfigLoader#loadFromCode 函数，该函数加载的配置的优先级同样取决于调用顺序。如果混用两种加载方式，也是先调用的生效。  下面，我们给出一个示例：\nimport {ConfigLoader, AllowNotFoundEnum} from 'swpp-backends'\nconst loader = new ConfigLoader();\nawait loader.loadFromCode({\n    compilationEnv: {\n        DOMAIN_HOST: new URL('http://localhost:8080'),\n        PUBLIC_PATH: 'publish/'\n    }\n})\n/*\n  example.ts:\n  import {AllowNotFoundEnum, defineConfig} from 'swpp-backends'\n  defineConfig({\n      compilationEnv: {\n          DOMAIN_HOST: new URL('https://example.com'),\n          ALLOW_NOT_FOUND: AllowNotFoundEnum.ALLOW_ALL\n      }\n  })\n */\nawait loader.load('config/example.ts')\nawait loader.loadFromCode({\n    compilationEnv: {\n        ALLOW_NOT_FOUND: AllowNotFoundEnum.REJECT_ALL\n    }\n})\n  最终生效的配置为：\nimport {AllowNotFoundEnum, defineConfig} from 'swpp-backends'\ndefineConfig({\n    compilationEnv: {\n        DOMAIN_HOST: new URL('http://localhost:8080'),\n        PUBLIC_PATH: 'publish/',\n        ALLOW_NOT_FOUND: AllowNotFoundEnum.ALLOW_ALL\n    }\n})","读取-swpp-配置#读取 swpp 配置":"您或许经常需要读取 swpp 配置，以此决定您是否执行某个操作或其它事情。  当您使用 ConfigLoader 加载配置后，可以调用 generate 函数生成最终的配置项。generate 函数会返回一个对象，其中包含 compilation 和 runtime 两个字段，前者是构建期可读的配置，后者是运行时可读的配置。这两个字段中会包含若干个 KeyValueDatabase，通过调用 KeyValueDatabase 的 read 函数即可读取指定配置。  推荐您使用具有完整类型推导和自动补全的 IDE（或编辑器），比如 WebStorm、vscode 等。因为 swpp 为配置项添加了复杂的数据类型（可能会难以阅读），IDE 可以通过这些类型为您提供自动补全和静态检查，以帮助您获取到更佳的开发体验。  接下来我们举一个🌰：\n// noinspection TypeScriptUnresolvedReference,JSUnusedLocalSymbols\nimport {ConfigLoader} from 'swpp-backends'\n// 我们假设您已经有了一个 ConfigLoader\nlet loader: ConfigLoader\nconst {runtime, compilation} = loader.generate()\n// 通过这个代码您可以读取 CrossDep 分支下的 matchCacheRule 配置\n// 当然，您可以使用 compilation.crossDep 代替 runtime.crossDep，这两者指向同一对象\nruntime.crossDep.read('matchCacheRule')","扫描网站资源#扫描网站资源":"swpp 将资源扫描的操作封装到了 ResourcesScanner 类中，创建该类的对象并调用其中的 scanLocalFile 函数即可完成资源的扫描，该函数接受一个文件路径（相对于项目根目录或绝对路径），该路径应当指向一个文件夹。该函数返回一个 FileUpdateTracker 对象，该对象记录了扫描的结果，除非您知道您在干什么，否则不要修改这个对象的内容。  调用 FileUpdateTracker 的 diff 函数即可获取到当前本地的文件与上一次构建时的差异，调用后 swpp 将自动从网络拉取上一次构建的结果。该函数返回一个 JsonBuilder 对象，除非您知道您在干什么，否则不要修改这个对象的内容。  调用 JsonBuilder 的 buildJson 函数，即可生成本次构建的版本文件，通过 JSON.stringify 函数将其转换为字符串。  调用 FileUpdateTracker 的 json 函数可以获取到本次构建的跟踪器（tracker）的 json 序列化字符串，其中包含下一次构建时需要重建的信息，diff 函数强依赖上一次构建生成的 tracker 的 json。  如果您想要将本次构建与上次构建的文件差异导出到文件，可以调用 JsonBuilder#serialize 函数，该函数将构建器的数据序列化为 json 字符串。  接下来我们举一个示例：\n// noinspection TypeScriptUnresolvedReference\nimport {ConfigLoader, ResourcesScanner} from 'swpp-backends'\n// 我们假设您已经有了一个 ConfigLoader\nlet loader: ConfigLoader\nasync function scannerAndGenerate() {\n    const {compilation} = loader.generate()\n    const scanner = new ResourcesScanner(compilation)\n    const tracker = await scanner.scanLocalFile('public')\n    const jsonBuilder = await tracker.diff()\n    const versionJson = jsonBuilder.buildJson()\n    const trackerJson = tracker.json()\n    return {versionJson, trackerJson}\n}\nconst {versionJson, trackerJson} = await scannerAndGenerate()\n// do somethings...","构建-sw-js#构建 SW JS":"SwCompiler 类用于构建 sw 文件，创建 SwCompiler 的对象并调用 buildSwCode 函数就能生成 sw 文件的 js 代码字符串。","构建-dom-js#构建 DOM JS":"构建 dom js 的操作相对比较特殊，dom js 的内容被保存到了 domConfig 中，这是一个 KeyValueDatabase，其中有两个用于构建源代码的函数：\nbuildJsSource - 该函数返回一个完整的 JS 文件的字符串，外部使用 DOMContentLoaded 事件包裹。\nbuildInnerSource - 该函数返回一个 JS 代码的字符串，内容是 buildJsSource 的事件内的代码，通常使用上者即可。","写入文件#写入文件":"根据不同平台，您需要自行决定使用什么方法将 swpp 生成的数据写入到文件中。  下面是各个文件写入的路径的读取方式：\n// noinspection TypeScriptUnresolvedReference\nimport nodePath from 'path'\nimport {ConfigLoader, SwCompiler, UpdateJson} from 'swpp-backends'\n// 假设已经有了需要的所有数据\nlet loader: ConfigLoader\nconst {runtime, compilation} = loader.generate()\nlet versionJson: UpdateJson\nlet trackerJson: string\nlet swJsCode = new SwCompiler()\nconst jsonInfo = compilation.compilationEnv.read('SWPP_JSON_FILE')\nconst publicRoot = compilationData.compilationEnv.read('PUBLIC_PATH')\n// 版本文件的内容\nconst versionJsonText = JSON.stringify(versionJson)\n// tracker 文件的内容\nconst trackerJsonText = trackerJson\n// sw 文件的内容\nconst swJsText = swJsCode.buildSwCode(runtime)\n// dom js 文件的内容\nconst domJsText = runtime.domConfig.buildJsSource()\n// 版本文件的路径\nconst versionJsonPath = nodePath.join(publicRoot, jsonInfo.swppPath, jsonInfo.versionPath)\n// tracker 文件的路径\nconst trackerJsonPath = nodePath.join(publicRoot, jsonInfo.swppPath, jsonInfo.trackerPath)\n// sw 文件的路径\nconst swJsPath = nodePath.join(publicRoot, compilation.compilationEnv.read('SERVICE_WORKER') + '.js')\n// dom js 文件的路径\nconst domJsPath = nodePath.join(publicRoot, '<这里自定义>.js')\n// diff 文件（构建器的序列化结果）的路径完全有您自己把控，swpp 不会依赖这个文件的内容"}},"/features/commonly":{"title":"常用配置列表","data":{"":"在本章中，将为您列出一些常用的配置项，以方便您快速配置 swpp。为了辅助您的阅读，本章中会使用下列标记：\n🌟 - 表示如果希望启用指定功能，则该项必填；\n☀️ - 表示如果希望启用指定功能，则该项必填，但前端实现有极大概率会自动填充该字段；\n🌙 - 表示该项可选（可能是具有默认值，也可能是留空也可以正常工作）。\n  注意：本文中对于某一项功能并不一定会列出所有与其相关的配置项，仅列出您需要更改的可能性比较大的配置项。","基本信息#基本信息":"为了告诉 swpp 一些基本信息，您可能需要配置下方的内容：\n☀️ 网站地址（CompilationEnv > DOMAIN_HOST）\n🌙 SW 文件的名称（CompilationEnv > SERVICE_WORKER）\n🌙 数据文件存储目录（CompilationEnv > SWPP_JSON_FILE）","数据文件相关#数据文件相关":"与数据文件的生成有关的常用配置项如下：\n🌙 数据文件存储目录（CompilationEnv > SWPP_JSON_FILE）\n🌙 HTML 数量限制（CompilationEnv > JSON_HTML_LIMIT）\n🌙 版本信息长度限制（CompilationEnv > VERSION_LENGTH_LIMIT）","本地缓存#本地缓存":"如果您需要启用本地缓存，那么您可能需要配置下面的内容：\n🌟 缓存规则（CrossDep > matchCacheRule）\n🌙 缓存库名称（CrossEnv > CACHE_NAME）\n🌙 逃生门（CrossEnv > ESCAPE）\n🌙 请求校验函数（RuntimeDep > isFetchSuccessful）\n🌙 CORS 模式（RuntimeDep > isCors）\n🌙 请求修改器（RuntimeDep > modifyRequest）\n🌙 链接归一化（CrossDep > normalizeUrl）\n🌙 版本信息地址（CrossEnv > VERSION_PATH）\n🌙 前端更新最短间隔（CrossEnv > UPDATE_CD）","备用-url#备用 URL":"如果您需要启用备用 URL，那么您可能需要配置下面的内容：\n🌟 获取备用 URL 列表（RuntimeDep > getStandbyRequests）\n🌙 请求校验函数（RuntimeDep > isFetchSuccessful）","url-竞速#URL 竞速":"如果您需要启用 URL 竞速，那么您可能需要配置下面的内容：\n🌟 获取 URL 竞速列表（RuntimeDep > getFastestRequests）\n🌙 请求校验函数（RuntimeDep > isFetchSuccessful）","构建优化及微调#构建优化及微调":"如果您想要提升构建速度或者进行一些个性化配置，您可能需要配置下面的内容：\n🌙 404 等级设置（CompilationEnv > ALLOW_NOT_FOUND）\n🌙 404 检查器（CompilationEnv > isNotFound）\n🌙 稳定链接筛选器（CompilationEnv > isStable）"}}}