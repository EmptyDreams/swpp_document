(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[907],{4774:function(e,n,i){(window.__NEXT_P=window.__NEXT_P||[]).push(["/features",function(){return i(8929)}])},8929:function(e,n,i){"use strict";i.r(n),i.d(n,{__toc:function(){return c}});var t=i(2676),r=i(7217),o=i(2435),s=i(9076);i(4869);var a=i(6151);let c=[{depth:2,value:"本地缓存和增量更新",id:"本地缓存和增量更新"},{depth:2,value:"缓存大小限制和预缓存",id:"缓存大小限制和预缓存"},{depth:2,value:"Request 篡改和 204 阻塞响应",id:"request-篡改和-204-阻塞响应"},{depth:2,value:"URL 竞速和备用 URL",id:"url-竞速和备用-url"},{depth:2,value:"逃生门",id:"逃生门"}];function d(e){let n=Object.assign({h1:"h1",p:"p",h2:"h2",a:"a",ol:"ol",li:"li",code:"code"},(0,a.a)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{children:"功能介绍"}),"\n",(0,t.jsx)(n.p,{children:"  在开始体验 swpp 前，我们先来了解一下 swpp 都有哪些功能。"}),"\n",(0,t.jsx)(n.h2,{id:"本地缓存和增量更新",children:"本地缓存和增量更新"}),"\n",(0,t.jsxs)(n.p,{children:["  一般情况下，我们浏览网站需要从服务器拉取文件（包括但不限于：html、css、js），然后浏览器才能渲染出最终的结果。为了提高用户体验、降低服务器压力，诞生了 ",(0,t.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching",children:"HTTP 缓存"}),"，不过 HTTP 缓存仍有一定的局限性：体系较为复杂、需要服务器支持、通常难以及时更新等……"]}),"\n",(0,t.jsx)(n.p,{children:"  而通过 Service Worker 进行本地缓存就能解决上述的很多痛点："}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["sw 的缓存体系非常简单，就是拦截用户请求然后使用 ",(0,t.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Cache",children:"Cache API"})," 读写缓存。"]}),"\n",(0,t.jsx)(n.li,{children:"sw 完全不依赖服务器实现，只要提供给用户 sw 的 js 文件，DOM 中添加相关支持，即可体验完整的功能。"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"  但是 Service Worker 整体有一定的复杂度，且使用简单的实现仍然无法解决无法及时更新缓存的问题，此时 swpp 就派上了用场。"}),"\n",(0,t.jsx)(n.p,{children:"  swpp 通过增量更新，在构建网站时扫描需要缓存的内容，确定本次更新需要更新哪些缓存，客户端就可以主动使这些缓存失效，从而解决缓存无法及时更新的问题。"}),"\n",(0,t.jsx)(n.p,{children:"  swpp 同时支持按时间过期和永久缓存两种缓存方式，两种方式都可以使用增量更新。"}),"\n",(0,t.jsx)(n.h2,{id:"缓存大小限制和预缓存",children:"缓存大小限制和预缓存"}),"\n",(0,t.jsx)(n.p,{children:"  预缓存是指在网站加载时，预先缓存一些用户可能使用的资源。该功能妥善使用的话可以优化用户体验，但是为了避免用户滥用，swpp 没有内置该功能。"}),"\n",(0,t.jsx)(n.p,{children:"  swpp 目前没有内置对缓存大小限制和预缓存的支持代码，但是用户可以通过自己配置，轻松实现这一功能。"}),"\n",(0,t.jsx)(n.h2,{id:"request-篡改和-204-阻塞响应",children:"Request 篡改和 204 阻塞响应"}),"\n",(0,t.jsx)(n.p,{children:"  启用 sw 后一个请求的流程为：DOM 端发送请求 -> SW 端拦截并处理请求 -> SW 端发送网络请求或直接返回。"}),"\n",(0,t.jsx)(n.p,{children:"  swpp 允许用户在 SW 端修改请求的内容，相当于一个本地的加强版重定向，同时也可以选择直接在 SW 阻塞掉某个请求。"}),"\n",(0,t.jsx)(n.h2,{id:"url-竞速和备用-url",children:"URL 竞速和备用 URL"}),"\n",(0,t.jsxs)(n.p,{children:["  对于 ",(0,t.jsx)(n.code,{children:"npm"})," ",(0,t.jsx)(n.code,{children:"cdnjs"})," 或 ",(0,t.jsx)(n.code,{children:"github"})," 之类平台上的资源，通常有多个 CDN 可用。"]}),"\n",(0,t.jsx)(n.p,{children:"  通过 URL 竞速，可以同时拉取这些 CDN 上的文件，然后取响应速度最快的一个作为最终结果。"}),"\n",(0,t.jsx)(n.p,{children:"  而通过备用 URL，则可以优先访问原始的 URL，如果响应超时或失败，则同时拉取剩余 CDN 上的文件，然后取响应速度最快的一个作为最终结果。"}),"\n",(0,t.jsx)(n.h2,{id:"逃生门",children:"逃生门"}),"\n",(0,t.jsx)(n.p,{children:"  swpp 的缓存增量更新需要 DOM 端发送消息到 SW 端，如果 DOM 端实现错误导致无法发送消息且 DOM 端代码被永久缓存，那么靠普通手段是完全没有办法解决这个死循环的，逃生门的作用就是触发时强制更新缓存来解开这个死局。"})]})}let l={MDXContent:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.a)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)},pageOpts:{filePath:"pages/features.mdx",route:"/features",timestamp:1724325243e3,pageMap:[{kind:"Meta",data:{index:"关于 swpp",features:"功能介绍",quickstart:"快速开始",config:"配置文件"}},{kind:"Folder",name:"config",route:"/config",children:[{kind:"Meta",data:{runtime_dep:"RuntimeDep",cross_env:"CrossEnv",compilation_env:"CompilationEnv",runtime_core:"RuntimeCore",cross_dep:"CrossDep",runtime_event:"RuntimeEvent",dom_config:"DomConfig",modifier:"Modifier",compilation_file_parser:"CompilationFileParser",special:"配置工具"}},{kind:"MdxPage",name:"compilation_env",route:"/config/compilation_env"},{kind:"MdxPage",name:"compilation_file_parser",route:"/config/compilation_file_parser"},{kind:"MdxPage",name:"cross_dep",route:"/config/cross_dep"},{kind:"MdxPage",name:"cross_env",route:"/config/cross_env"},{kind:"MdxPage",name:"dom_config",route:"/config/dom_config"},{kind:"MdxPage",name:"modifier",route:"/config/modifier"},{kind:"MdxPage",name:"runtime_core",route:"/config/runtime_core"},{kind:"MdxPage",name:"runtime_dep",route:"/config/runtime_dep"},{kind:"MdxPage",name:"runtime_event",route:"/config/runtime_event"},{kind:"MdxPage",name:"special",route:"/config/special"}]},{kind:"MdxPage",name:"config",route:"/config"},{kind:"MdxPage",name:"features",route:"/features"},{kind:"MdxPage",name:"index",route:"/"},{kind:"Folder",name:"quickstart",route:"/quickstart",children:[{kind:"Meta",data:{hexo:"Hexo 安装教程"}},{kind:"MdxPage",name:"hexo",route:"/quickstart/hexo"}]},{kind:"MdxPage",name:"quickstart",route:"/quickstart"}],flexsearch:{codeblocks:!0},title:"功能介绍",headings:c},pageNextRoute:"/features",nextraLayout:o.ZP,themeConfig:s.Z};n.default=(0,r.j)(l)},9076:function(e,n,i){"use strict";var t=i(2676);i(5271);var r=i(5458);let o="Swpp 官方文档";n.Z={logo:(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)("svg",{xmlns:"http://www.w3.org/2000/svg",width:"24",height:"24",className:"icon",viewBox:"0 0 1024 1024",fill:"currentcolor",children:[(0,t.jsx)("path",{d:"M469.333 810.667V341.333a128 128 0 0 0-128-128H128v597.334zM512 213.333A212.992 212.992 0 0 1 682.667 128h298.666v768H42.667V128h298.666c69.803 0 131.755 33.493 170.667 85.333m42.667 128v469.334H896V213.333H682.667a128 128 0 0 0-128 128"}),(0,t.jsx)("text",{xmlSpace:"preserve",x:"215",y:"485",fillOpacity:"null",stroke:"null",strokeOpacity:"null",strokeWidth:"0",fontFamily:"'Courier New', Courier, monospace",fontSize:"250",fontWeight:"bold",transform:"matrix(2.177 0 0 2.07854 -332.879 -331.617)",children:"S"}),(0,t.jsx)("text",{xmlSpace:"preserve",x:"653",y:"499",fillOpacity:"null",stroke:"null",strokeOpacity:"null",strokeWidth:"0",fontFamily:"'Courier New', Courier, monospace",fontSize:"250",fontWeight:"bold",transform:"matrix(1.78385 0 0 2.06235 -570.614 -357.776)",children:"W"})]}),(0,t.jsx)("span",{style:{marginLeft:".4em",fontWeight:"bold"},children:o})]}),sidebar:{defaultMenuCollapseLevel:1},project:{link:"https://github.com/EmptyDreams/swpp-backends"},docsRepositoryBase:"https://github.com/EmptyDreams/swpp_document/tree/main/",useNextSeoProps:()=>({titleTemplate:"%s – ".concat(o)}),footer:{text:"\xa9 2024-present ".concat(o)},head:(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)("meta",{name:"viewport",content:"width=device-width, initial-scale=1.0"}),(0,t.jsx)("meta",{property:"og:description",content:"Service Worker Plus Plus 的官方文档"}),(0,t.jsx)("meta",{name:"keywords",content:"ServiceWorker, swpp"})]}),...r.Z}},5184:function(){}},function(e){e.O(0,[556,888,774,179],function(){return e(e.s=4774)}),_N_E=e.O()}]);