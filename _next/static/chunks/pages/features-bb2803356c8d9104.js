(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[907],{9774:function(e,n,s){(window.__NEXT_P=window.__NEXT_P||[]).push(["/features",function(){return s(9163)}])},9163:function(e,n,s){"use strict";s.r(n),s.d(n,{__toc:function(){return d}});var r=s(2676),i=s(7217),h=s(6151);let d=[{depth:2,value:"本地缓存和增量更新",id:"本地缓存和增量更新"},{depth:2,value:"缓存大小限制和预缓存",id:"缓存大小限制和预缓存"},{depth:2,value:"Request 篡改和 204 阻塞响应",id:"request-篡改和-204-阻塞响应"},{depth:2,value:"URL 竞速和备用 URL",id:"url-竞速和备用-url"},{depth:2,value:"逃生门",id:"逃生门"}];function l(e){let n=Object.assign({h1:"h1",p:"p",h2:"h2",a:"a",ol:"ol",li:"li",code:"code"},(0,h.a)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{children:"功能介绍"}),"\n",(0,r.jsx)(n.p,{children:"  在开始体验 swpp 前，我们先来了解一下 swpp 都有哪些功能。章节下的子目录是对各个功能的具体说明，可以先跳过回过头再看，但是一定要记得回来看！！！里面会说明功能使用时的注意事项。"}),"\n",(0,r.jsx)(n.h2,{id:"本地缓存和增量更新",children:"本地缓存和增量更新"}),"\n",(0,r.jsxs)(n.p,{children:["  一般情况下，我们浏览网站需要从服务器拉取文件（包括但不限于：html、css、js），然后浏览器才能渲染出最终的结果。为了提高用户体验、降低服务器压力，诞生了 ",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching",children:"HTTP 缓存"}),"，不过 HTTP 缓存仍有一定的局限性：体系较为复杂、需要服务器支持、通常难以及时更新等……"]}),"\n",(0,r.jsx)(n.p,{children:"  而通过 Service Worker 进行本地缓存就能解决上述的很多痛点："}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["sw 的缓存体系非常简单，就是拦截用户请求然后使用 ",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Cache",children:"Cache API"})," 读写缓存。"]}),"\n",(0,r.jsx)(n.li,{children:"sw 完全不依赖服务器实现，只要提供给用户 sw 的 js 文件，DOM 中添加相关支持，即可体验完整的功能。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"  但是 Service Worker 整体有一定的复杂度，且使用简单的实现仍然无法解决无法及时更新缓存的问题，此时 swpp 就派上了用场。"}),"\n",(0,r.jsx)(n.p,{children:"  swpp 通过增量更新，在构建网站时扫描需要缓存的内容，确定本次更新需要更新哪些缓存，客户端就可以主动使这些缓存失效，从而解决缓存无法及时更新的问题。"}),"\n",(0,r.jsx)(n.p,{children:"  swpp 同时支持按时间过期和永久缓存两种缓存方式，两种方式都可以使用增量更新。"}),"\n",(0,r.jsx)(n.h2,{id:"缓存大小限制和预缓存",children:"缓存大小限制和预缓存"}),"\n",(0,r.jsx)(n.p,{children:"  预缓存是指在网站加载时，预先缓存一些用户可能使用的资源。该功能妥善使用的话可以优化用户体验，但是为了避免用户滥用，swpp 没有内置该功能。"}),"\n",(0,r.jsx)(n.p,{children:"  swpp 目前没有内置对缓存大小限制和预缓存的支持代码，但是用户可以通过自己配置，轻松实现这一功能。"}),"\n",(0,r.jsx)(n.h2,{id:"request-篡改和-204-阻塞响应",children:"Request 篡改和 204 阻塞响应"}),"\n",(0,r.jsx)(n.p,{children:"  启用 sw 后一个请求的流程为：DOM 端发送请求 -> SW 端拦截并处理请求 -> SW 端发送网络请求或直接返回。"}),"\n",(0,r.jsx)(n.p,{children:"  swpp 允许用户在 SW 端修改请求的内容，相当于一个本地的加强版重定向，同时也可以选择直接在 SW 阻塞掉某个请求。"}),"\n",(0,r.jsx)(n.h2,{id:"url-竞速和备用-url",children:"URL 竞速和备用 URL"}),"\n",(0,r.jsxs)(n.p,{children:["  对于 ",(0,r.jsx)(n.code,{children:"npm"})," ",(0,r.jsx)(n.code,{children:"cdnjs"})," 或 ",(0,r.jsx)(n.code,{children:"github"})," 之类平台上的资源，通常有多个 CDN 可用。"]}),"\n",(0,r.jsx)(n.p,{children:"  通过 URL 竞速，可以同时拉取这些 CDN 上的文件，然后取响应速度最快的一个作为最终结果。"}),"\n",(0,r.jsx)(n.p,{children:"  而通过备用 URL，则可以优先访问原始的 URL，如果响应超时或失败，则同时拉取剩余 CDN 上的文件，然后取响应速度最快的一个作为最终结果。"}),"\n",(0,r.jsx)(n.h2,{id:"逃生门",children:"逃生门"}),"\n",(0,r.jsx)(n.p,{children:"  swpp 的缓存增量更新需要 DOM 端发送消息到 SW 端，如果 DOM 端实现错误导致无法发送消息且 DOM 端代码被永久缓存，那么靠普通手段是完全没有办法解决这个死循环的，逃生门的作用就是触发时强制更新缓存来解开这个死局。"})]})}n.default=(0,i.j)({MDXContent:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,h.a)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)},pageOpts:{filePath:"pages/features.mdx",route:"/features",timestamp:1724556256e3,title:"功能介绍",headings:d},pageNextRoute:"/features"})}},function(e){e.O(0,[217,888,774,179],function(){return e(e.s=9774)}),_N_E=e.O()}]);